<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Title of the report" />




<meta name="author" content="Author Name" />


<meta name="description" content="Title of the report">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","date":"Date","subtitle":"Subtitle of the report","output":{"pagedreport::paged_windmill":{"img_to_dark":true,"front_img":"trees.jpg","logo_to_white":true,"logo":"<a href=\"https://www.r-project.org/logo/Rlogo.svg\" class=\"uri\">https://www.r-project.org/logo/Rlogo.svg</a>"}},"author":"Author Name","knit":"pagedown::chrome_print","title":"Title of the report","main-color":"#6cabdd"}
</script>

<title>Title of the report</title>


<link href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI3MjRweCIgaGVpZ2h0PSI1NjFweCIgdmlld0JveD0iMCAwIDcyNCA1NjEiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDcyNCA1NjEiIHhtbDpzcGFjZT0icHJlc2VydmUiPiAgPGltYWdlIGlkPSJpbWFnZTAiIHdpZHRoPSI3MjQiIGhlaWdodD0iNTYxIiB4PSIwIiB5PSIwIgogICAgaHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUF0UUFBQUl4Q0FRQUFBREhyZWRLQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk4KQUFCNkpnQUFnSVFBQVBvQUFBQ0E2QUFBZFRBQUFPcGdBQUE2bUFBQUYzQ2N1bEU4QUFBQUFtSkxSMFFBLzRlUHpMOEFBRUh5U1VSQgpWSGphN2QxM21CWGwzY2J4N3k0ZDZVVlFFUVNWS3FKaXBhZ29ZbThnR2l4WVVaUFlvckVrYWpUbWpTVW1zV0xCamdVaklBcllBb29nCktLaXJBdEpFUURvb2hONlgzZmVQQlZ6ZzdPNlpjNTZaMzVUNzQ1VkxnWE5tN2prWmI1OTl6c3c4T1lXSWlFaVk1Vm9IRUJHUjBxbW8KUlVSQ3JyeDFBSkZkVktmbXRyK3FVWTFLMUtRcWxhaE5KYXF5QnhYSm9SWlFtU3BBeldKRGpXcFUyR2s3bTFtMzQ1L3pXUU9zWXpPRgpyQVEyc29HMWJHSVZHOWpJU2pheGp0V3NZaldyV01WYTY0OUFaR2M1bXFNV0E3V29UejNxYnZ1ckh2V29TdzFxVW51bjZyV3lsVldzClpDV3JXTVl5bHUvNGF4ay9zOFk2bkNTUmlscjhWWTZHTkdGUDltWlBHcklYZTdJUGUxTEpPbGJHTnJDRXhmek1JbjVtTVV0WXdueVcKVW1BZFMrSk5SUzF1TmFBcCs3SVBUZGlIZldoQ1E4cFpSL0xkRmhZeG4va3NaRDd6bWM5UExMT09KUEdpb3BiczFLQVpUV2xLVS9hagpLVTJwYWgwb0ZOWXdoem44eEJ4bTh4T3ppODJXaTJSQVJTMWVWV0lmMnRDYVpqU2pHVTNKc1E0VUFTdVl6VlNtTUp2WlRGZHRpMWNxCmFrbEhmZHJRaXRhMG9nV05yTU5FWEFIem1jRVVwakdWcWF5d2ppTlJvS0tXa3RTaEhXMXBUU3ZhVU5jNlRHd3RZU3JUbU1Ka0pyUEsKT295RWxZcGFpaXRQWTlyUW52YTAxcVJHNEJZemhhbmtrY2QwdGxxSGtUQlJVUXRVb2kzdGFVOTcya1Q0d3JrNFdjOGs4dmlHUEthUQpieDFHN0ttb2s2c2k3VGlNOXJTbjdTNzM5RWw0YkdRaWVlU3BzcE5OUlowOGU5T2VqblRpTUtwWVJ4RVAxdkVkZWVUeEdYT3NvMGpRClZOUkpVWlVqNmNCUkhFVUQ2eWlTcGZtTVp6emorWnJOMWxFa0dDcnF1S3ZCa1hTaUk1MDEreHc3VzVqRVNNWXhWaGY1eFoyS09xNzIKb1F1ZDZFd3JYYnNSZTF1WnhHZDh4bWgrc1k0aS9sQlJ4ODJlSEVjbk9uS1lDanFCWmpPU2tYekNjdXNnNHBhS09pNXEwNFV1bkVCcgo2eUJpcm9EdkdNVW9SdXZKMm5HaG9vNjZjaHhDVjdweW5DNnhrMTNrTTVHUkRPZHpQWVkxNmxUVTBkV01yblNsSzdXdGcwaklMV01VCkkvbVFlZFpCSkZNcTZ1Z3B4ekdjUVZmYVd3ZVJpSm5OY0lZeG1pM1dRY1FyRlhXVTFPZFV6cUFiTmEyRFNJVDlqNDhaeVZDV1dBZVIKOUttb28rRVF6dVlzRHRXVkhPTElWc1l6bEhmNHdUcUlwRU5GSFc1RjB4em4wdHc2aU1UVWJJWXpVRjgzaHAyS09xeXEwSTF6T0lONgoxa0VrQVJZeWxIY1lwZG5yc0ZKUmgwOWxUcUluWjFQRE9vZ2t6QXFHTTVDUDlBU1I4RkZSaDRrcVd1eXBya05JUlIwT0ZUbVZYcHpCCkh0WkJSQUJZd1R1OHdTaXROQk1PS21wcnVYU2dKNzJvYngxRVpEZkxHY3lyakVNMVlVeEZiYWtOUGJtRVp0WXhSRW8xbHpkNWlSblcKTVpKTVJXMWpMeTdpTXRwWXh4Qkoyd1Q2TTBCUHZyYWhvZzVhSmJweENlZm9FVW9TUVpzWVFYL2UwV1Y4UVZOUkI2azl2YmxRVjBaTAp4QzFtSUMveG5YV01KRkZSQjZNbUYvQTcybG5IRUhFbWozNjhvU2RlQjBORjdiLzJYTTNGVkxXT0llTGNHZ2J3S21PdFk4U2ZpdHBQCjllbE5IMXBZeHhEeDFUYzh4eHVzdG80Ulp5cHF2N1RuYWk2aGluVU1rVUNzNVEzNk1zazZSbHlwcU4ycnhGbmNSQWZyR0NLQnkrTngKQnVpYUVQZFUxRzd0VHgrdTFIVWRrbUJMZUlXK3pMZU9FUzhxYW5jNmNRUGRLV2NkUThUY1ZqN2dmcjZ3amhFZkttb1hLbkkydDNDVQpkUXlSVU1uamNkNGczenBHSEtpb3MxV2ZLN2lPUnRZeFJFSnBEcy9TVHplZVowdEZuWTBEdVlWTHFXd2RReVRVVnZNY2o3RFFPa2FVCnFhZ3pkU2gvb0JmbHJXT0lSTUlXM3VRaHBsakhpQ29WZFNZNmNUdG5XSWNRaVpoQzN1TkJ4bG5IaUNJVnRUZmxPSi9iOWN3T2tZeU4KNVVIZTExSUUzcWlvMDVkTEQrNmpwWFVNa2NpYnhMOTRqUUxyR05HaG9rNVBCWHB4SjgydFk0akV4dmM4ek90YWt6RTlLdXF5VmVKSwpicWV4ZFF5UjJKbkcvUXhRV1pkTlJWMjZDdlRpWHBwYXh4Q0pyVGs4eUFzcTY5S3BxRXVXU3cvdTV3RHJHQ0t4TjVXSE5HZGRHaFYxCmFybjA0UDgwSnkwU21PKzVqMEc2R2lRMUZmWHVjamlYKzdSQ3VFamdKdkJuUHJFT0VVWXE2bDBkelQvb2JCMUNKTEZHY2p2ZldJY0kKbTF6ckFLSFNpcmY0UWpVdFlxZ3JYL01XKzF2SENCZU5xTGRyeE4xY3FhZEppNFRDRmw3aUx5eTFqaEVXS21xQTZ2eUptN1Mrb1VpbwpyT0lCSG1XVGRZd3dVRkhuY2pFUDBkQTZob2lrTUorN2VGWFhnaVM5cUUvZ1h4eGlIVUpFU3ZFbGYrQno2eEMya3Z4bFlndUc4ckZxCldpVGtqdVF6K3JPUGRReExTUjFSVitVMjdxQ1NkUXdSU2RONkh1YUJwTTVZSjdPb3orUkpQV1JKSkhKKzVFYmV0dzVoSVhsRjNZTEgKNldZZFFrUXlOSndibUdNZEltakptcU91d2FOOHI1b1dpYkF6bU1LOVNWdFNPa2tqNmpQcHk3N1dJVVRFZ1ZuOG5vK3NRd1FuS1NQcQpmUmpNVU5XMFNFenN6NGU4eFo3V01ZS1NoS0l1ejQxTXA3dDFEQkZ4cWljenVERVJIWmFBcVkrajZNZkIxaUZFeENkanVZYXAxaUg4CkZ1Ly9HbFhoUWNhcHBrVmlyQlBmOFNBVnJXUDRLODRqNm82OFFBdnJFQ0lTZ01sY3dkZldJZndUMXhGMVZSNWtqR3BhSkNIYThnVVAKeHZkZTQzaU9xRS9pT1pwWWh4Q1JnRTNsU3NaYmgvQkQvRWJVVlhpUUQxWFRJZ25VbXJIeEhGZkhiVVI5Tks5bzdYQ1JSUHVlM254cgpIY0t0T0kyb0szQXZZMVhUSWdsM0VCTzROMTdMNnNWblJIMEkvV2xySFVKRVFtSWNsekxMT29RcjhSaFI1M0FqNDFYVElySkRSeVp6Cm8zVUlWK0l3b3Q2VGx6ak5Pb1NJaE5CZytyRENPa1Qyb2wvVTNYaVp2YXhEaUVoSXplTmlQck1Pa2Exb1QzMVU1akUrVkUyTFNJa2EKTTRvSHFXQWRJenRSSGxFMzV5M2FXWWNRa1FnWVF5OFdXWWZJWEhSSDFPY3lRVFV0SW1rNWxvbWNZaDBpYzlFczZrbzh4dHZVc280aApJcEZSai9kNU1LcFhWMGR4NnFNSi8rRW82eEFpRWtHZmNpR0xyVU40RjcwUjlibE1WRTJMU0VhTzV4dU90UTdoWGJTS09vZmJHVVJOCjZ4Z2lFbGtOK1pqYnJVTjRGYVdwanhyMDUyenJFQ0lTQXdPNGl2WFdJZElYbmFJK21DRTBzdzRoSWpFeGtlN010ZzZScnFoTWZmVGkKQzlXMGlEalRqaS9wWmgwaVhWRW82aHp1NVhXcVdzY1FrVmlweS90Um1hME8vOVJITmZwenJuVUlFWW1wRi9nZG02MURsQ1hzUmQySQpkem5NT29TSXhOZzR1dk96ZFlqU2hidW9PL0EyRGF4RGlFak16ZVlzcGxpSEtFMlk1Nmg3ODRscVdrUjgxNHpQdy8wa2tQQVc5WTI4CkhNZlZoRVVraEdvd25OOWFoeWhaT0tjK0t2QU1WMWlIa01RcVlCWHIyTUJxMXJLZXRheG02N2JmTGJKdTI1ZFBXMW05N1hlcUZYdmUKY1htcTcvam5HcFNqT3VXcFJnWDJvQ0pWcVVRVktsT1pLdFlIS1NuOG5ic0paU1dHc2Fpck15ZzYxemRLSksxbE9iK3dqT1VzWi9tMgp2NjlrQXh0WXdYbzJCWktoSnRXcFRnMnFVNXNhMi82NUJyV29RVTNxVVY5UGh6VHhHbGVHOFJxUThCWDFQcnluNTB5TE0xdFl3bndXCnNwRDVMR0xKdG1vT3BvcXpVNEY2MUtVZTlhbS83Wi9xMFpBRyt0N0daNlBvemtyckVMc0tXMUczNEw4MHRnNGhrVlhBQXVZd2o0VXMKWWg2TFdNQlNDcXhET1ZhUnZXakUzdXhOSXhxeUwzdlJTTGVET1RXWlU4SzJHa3k0aXZwdzNxZStkUWlKbE0zOHhDeG1NWXNmbWNYcwpTSXlWM2F2RlBqU2o2WTcvN1dFZEtPTG1jREl6clVNVUY2YWlQcEVoeGI2R0VVbXRrTGxNWWRxMmFwN0hWdXRBSWJSbnNkcmVYeitqClptQXBwL0t0ZFloZmhhZW96K1pOS2x1SGtOQmF3VlNtTUpVOEpyTEdPa3pFVk9JQVd0T0cxalNqamY0dFM5TmF1alBDT3NSMllTbnEKcTNrcXFxdVppVzlXOHgxVG1jUlVKdk0vNnpBeFVZRURhRVZMV3RPU2czU25RcWsyOGh2ZXRRNVJKQnhGL1Z2NmttTWRRa0ppTTVNWgpSeDU1VEl2ZEY0SGhVcDRXdEtZTjdUbEszdzJsdEpYTGVkVTZCSVNqcUcvakllc0lZbTRMTThramp6eStET04xckxHM04rMXBUMnZhCjBFcURwbUsyMG9lWHJFT0VvYWp2NVI3ckNHSm9ObU1aeDFkOHp4YnJLQUpBUFk3bUtEcHdoTDdhQjZDQTM5TFBPb1IxVWQvSDNkWWYKZ1ppWXpVakdNWWFmcklOSUNjclJrdlowcEJNdFEveE1vQ0FVY2pPUDJrYXdMZXBIdU1uMjhDVmdtL21henhqTDJQRGQreVVscXN2UgpIRVVuamtud0ZTTzM4ay9MM1ZzVzlUKzV4ZkxRSlVENWZNa0lSdkVsRzZ5alNNWXFjd3hkT0lFaml6MkNLamx1NWhHN25kc1Y5ZC81CnM5MWhTMkJtTTVLUmpHU0ZkUkJ4cGlvZDZFcW5oQlYySVRmeWhOWE9yWXBhTlIxM0svaUVFWXhndG5VUThVMHRqdU1FVHVWQTZ5QUIKS2VUM1BHMnphNXVpL2l0L3NUbGM4VjBCRS9pQUVYeWxXN3NUb3ptbmN6ckhKbUI4WGNnMVBHZXhZNHVpL2pOL3R6aFU4ZGtHUHVaZApockhVT29pWXFFRTNUdU8wbUQrR3RZREw2Ui84Ym9NdjZ0L3lWUENIS2I1YXhuQ0c4bC9XV1FjUmM3a2N6dW1jVG52cklMN0o1N3pnCmJ5d1B1cWd2NU5XRVg1TVpMM01ZeGpCRzYyWVYyVVZqenFVbkhXSjVsK05tenVLallIY1piRkdmenBBRXpHTWx3M1RlWkJCVHJHTkkKcURYamZIcHltSFVNNTliUWxTK0QzR0dRUlgwTUkvUkE4eGlZenhBR010WTZoa1JHRTg2aEp4MnRZemkxa3VPWkdOenVnaXZxZG95bQpabkFISmo1WXdrRGU1SXR3cnRNc0lkZWNDN2lVL2Exak9MT1FEc3dMYW1kQkZmVStmTUcrUVIyVU9MZVNZUXprQS9LdGcwakV0ZWRxCkxxU2FkUXducHRJcHFCdTVnaW5xV295bFRUQUhKSTdsOHo0djhLRWVQU3JPVktjbmw5TXhCbDgwZnNvcHdhelNHVVJSVitSOVRnemkKWU1TeEh4akFpOEg5ZUNlSjBwd0x1WlQ5ckdOazZTMTZCYkc4aGY5Rm5jTWIvTWIvQXhHbjFqR0lGeGlyMldqeFZUbTY4WHRPamZRbAp1dzl6bS84NzhiK29IK0FPL3c5REhKckFpN3pKYXVzWWtoZ0hjQjJYVThNNlJzWis1LzhUUVB3dTZrc3NicmVVREszaVpaN25lK3NZCmtrRFY2YzMxdExDT2taRjhUdUZqZjNmaGIxRjM0Qk90Y3h3Uk0rbkxDNnkxamlHSjFva2I2RTQ1NnhpZXJlQm9mdkJ6QjM0V2RSTW0KeFB3QkxmRlF3SHM4enNlYWo1WlFPSkFidUlLcTFqRTgrb0dqL2J4VXo3K2lyc1pZMnZrWFhKeFl6WnM4d25UckdDSTdxYy92dVpGYQoxakU4R2NOSi9sM0U2bGRSNXpDWWMvMEtMVTVNNFVsZTFSUHZKS1JxY3dNM1VNYzZoZ2RQY3IxZm0vYXJxUFhNNlhBYnhZT00wR1NICmhGeDFmc3ZORVpwQXZkU3ZpeWY4S2VxdWZCakJMd1NTb1pEM3VKOHZyR09JcEtrU2wzSlhSQjVBc1pGTzVQbXhZVCtLdWlsZlIrb0gKbHVUSTUwMGUxS05KSlhJcWNpMTNVZDg2UmhybWNEai9jNzlaOTBWZG1iRXhYdDBodWpiekgvN0dUT3NZSWhuYWcrdTRrK3JXTWNvMAprbFBjcnhmcS90Yk5aMVhUb2JPYWgyaE1iOVcwUk5nNkhxSWwvVUwvQk1ldTNPdCtvNjVIMUpmellpQWZocVJyTFkveHI2QWV4aWppCnUxYmN6em5XSVVwVndDbU1jTHRKdDBYZG5LOGo4S05KY216bVplNWxzWFVNRWNlTzRoOGNheDJpRkQ5ektJdGNidEJsVVZkbXZHNXgKQ1kwQ0JuTUhzNjFqaVBqa1RKNmlrWFdJRW4xS1Y1Y3oxUzducUI5WFRZZEVJUU5weGZtcWFZbXhZUnpFNCs2L3RuUGtlUDdzY25QdQpSdFMvWVVEd240YWtNSXk3bUdRZFFpUVFoL0UwUjFxSFNHa3JKekRHMWNaY0ZYVmpKa2JzenZ4NEdzL051cGxGRWlXWFB0d2Z5anMzCjVuRXdxMXdkcEp1dHZLU2FOcmVJYStpb21wYUVLZUJaRHVUeElCYkU4cWd4VDdyYWxKc1I5UzM4MCs3VEVHQUQvK1FoUFdCSkV1eDQKWHFTcGRZamRYTUJiTGpiam9xamI4RFdWclQrUFJCdk9EY3l4RGlGaXJDb1BjSDNJMWpaZnljSE16MzR6MlU5OVZPSjExYlNoYnppTwpNMVhUSXF6blJrNWxvWFdNbmRUaVJSZi82Y2krcU8vUlJYbG1mdVpLam5EM3piSkk1SDFFT3daYWg5aEpWNjdOZmlQWlRuMjA0eXNxCldIOFNpVlRJYTl6TU11c1lJaUhVazZlcGF4MWloM1cwemZabjN1eEcxT1Y1U1RWdFlnWmQ2SzJhRmtscElPMzRyM1dJSGZiZ3FXdzMKa1YxUjM4NmgxcDlCQW0zaElRNWh0SFVNa1JCYnlDbmNFWnI3RmsvaDB1dzJrTTNVUnd1KzA5ZUlnUnZITlhyMHYwaGF1akFnSkF0NQpyYUpOTmw5elpqNml6dVVGMVhUQVZuSU5uVlhUSW1rYXhSRk1zQTRCUUUwZXkrYnRtUmYxRlhTMFB2YUVHVUlyK21sQldoRVA1bk1zCmZhMURBTkNEVXpOL2M2WlRIM1dZUVQzckkwK1ExZHhLUCtzUWFhdHRIVUFDdElHTjFoSEtkQ0g5Mk1NNkJMTTRLTlBQS3RPaWZwNHIKclk4NlFjWndLVDlaaC9CQW8vNWsyY1FxVnJLS0pTeGdNZk5ZeER4bXM4VTYxazRPNG0wT3RBN0JmZHlUMlJzeksrcU9mQmF5R3pYagphd3YzODdmUWZIdWRIaFcxNURPSDZjeGdCak9ZRm9vTFNldndEcDJOTTJ5aUhUTXllV01tUlYyZVBBNDJQdUNrbU16RkVYeTJ0SXBhCmRyYVlQUExJWXp5L0dLYW96S3VjWi94SmZNUXBtYnd0azZLK25zZU5EellaQ25tQzI5aGtIU09qNUNLcHplSnJ2bUk4WDVwTWplUncKVDZhVEQ4NmN3N3NaQlBmODcxUnRab2JvNXN6NFdzUkZmR29kSWtNcWFpbkxPajduVXo3bFMvSUQzdk4xUEVvNXd5T2Z5VUZzOXZvbQo3MFg5Q0RjWkhtUlNqT1kzTExFT2tURVZ0YVJySGFNWXh2c3NDSENmSnpPUTZvYkhmQXYvOXZvV3IwWGRuTWxVTkR6RUpDamdmdTZOCjJOZUhPMU5SaXplRmZNczdER1pxUVBzN2ttSHNhWGEwS3puUTY5ZXJYb3Q2S0dlYUhWNHlMS2MzNzF1SHlKS0tXakl6bmJjWnhMY0IKN0trNUk5blg3RGo3Y3AyM04zZ3I2aTU4WW5ab3lmQWw1elBYT2tUV1ZOU1NqZW44aDFkOFh3eGpQejZtbWRFUjV0T1c2VjdlNEsybwpQK2NZb3dOTGhuNWM3LzFyaGhCU1VVdTJDaGhGZndheDNzZDlOR1FFQnhrZDN5QjZlbm01bDZJK2h5RkdCNVVFNjdpS042MURPS0tpCkZqZFc4UitlNEh2ZnR0K0FVYlF5T2JKQ2p1VHI5RitlZmxIbjhvMFczZkxOWXM3eThuOWJ5S21veFoxQ1B1WnBodnAwR1o5ZFZYdTYKOVNYOW9yNkUvaWFIa3dTVE9KTjUxaUVjVWxHTGF6L3hLTS81TWhIU2lFL1ozK1NZVG1CVXVpOU50NmdyTXMxczRqM3UzdVVpMWxtSApjRXBGTFg3NGhhZDRuUDg1MzI0VHh0RFk0SGkrb0VPNkwwMzNlZFNYcWFaOThqamRZMWJUSXY2b3p6Mzh4SVBVY2J6ZHVYUmxxY0h4CkhKUCs1RWQ2SStweVRBdkJJd0xqSjUrYlF2SlFjN2Mwb2hZL3JhVXZEN0RLNlRhUDRCT3FCWDRrYVkrcDB4dFJYNmlhOXNFS1RvbGwKVFl2NHF4cTNNNHZicWVKd20xL1IzZURTMkdQb2t0NEwweGxSNS9LOTBmZWljYmFRYm9IZE1CczBqYWdsQ0hPNWhjRU90OWVibHdOLwp6djdIZEUzblplbU1xSHVvcHAyYnczR3hyV21SWURSaEVKODR2R1dsUC84WCtER2NtTjdhcyttTXFML2xrTURqeDl2M2RHT3hkUWdmCmFVUXR3ZG5DMDl6TmFpZmJ5dUYxZWdXYy96M09TQ05ZbWY5T2RXVkV3TUhqN2t0TzllRVNvekJSVVV1d0ZuRXR3NXhzcVRLZkJQeWcKakVJT0t2dW42N0tuUG00T05IVDhqZWFrbU5lMFNORDJaaWh2T1ZuUVpDUGRXUmhvOXB4MG52QmYxb2k2QlZQVHZ0WmF5amFjODlsZwpIY0ozR2xHTGhTVmNtOGt5VjdzNW1rK3BGR0R1VFRRcDZ6cnVza3I0RnRXMFE2OXpiZ0pxV3NSR1E5N2hSUWRydDR6bnhrQnpWK0xxCnNsNVMrb2k2UG5PZFhxdVliRzl5Y2FUWGJVbWZSdFJpNXdkNk1pbnJyYnpNcFFGbVhzSitwUzlqWGZwNCtSclZ0RE5ENloyUW1oYXgKMUp3SjlNbDZLNzluV29DWkczSkI2UzhvYlVTZHkyeWFCQmcyemo3bUREWmFod2lNUnRSaTdWV3V6ZkpaZXdjeGdhcUI1ZjI4OU91cApTeHRSbjZxYWRtUXNaeVdvcGtYc1hjTG5XZmJYOS93aHdMd2RPTGkwUHk2dHFLOEpNR2FjZmNkWnZpNG9KQ0s3YThkNGpzaHFDLzJjCjNxQmVsbEsvVUN4NTZxTVJQMUV1d0poeE5aa3VMTGNPRVRCTmZVZzRyT09pckM3WXE4OWtHZ1NVZFEzN3NLYWtQeXg1UkgyVmF0cUIKbVhSTFhFMkxoTVVlRE9hR0xONy9TNER6Q3RWTCswS3hwQkYxTG5OTTFqeUlsMlVjdzQvV0lReG9SQzFoOGlnM1ozRk92c1JsQWVVYwpYL0xONnlVVjlRbDhIRkM0K05yQ3llbXZpUllyS21vSmx4ZTRtb0lNMzF1VHFld2RVTTZXekVqOUJ5Vk5mVndTVUxENEt1VEtoTmEwClNOaGNTYitNNzdGZUZlRFZIeGVWOUFlcFI5UlZXRXpOd01MRjAzM2NZeDNCakViVUVqNHYwaWZqVWZVUXpna2s0MXlhcHY2M0ovVi8KWmM1UlRXZnBUZTYxamlBaXhWekI4eG1QcXE5bmJTQVptOUFwOVIra0RxNkpqK3g4d2VVYVZZcUV6T1U4bGVFN0Z3UzI5a3NKM1p0cQo2cU11U3lnZlVLdzRtc1BSL0d3ZHdwVCtJeVZoOVNjZXpPaDlGWmxNOHdEeS9ZK0diTm45dDFPTnFNOVdUV2RoRStjbHZLWkZ3dXYrCkRPY0xObk45SVBucWNIeXEzMDVWMU9jR0VpaXVidUViNndnaVVvSWNudWZFak43NVg5NFBKR0dQbExGMyt5bTFPajlUT1pCQWNUU0kKbnRZUlFrQlRIeEptcStqTTVBemUxNHBKQWN3MkxHTXY4bmY5emQxSDFHZXBwak0yaTZ1c0k0aElHV3J5THJVemVOODArZ2VRcmw2cQpCNTd1WHRTYStNalVKaTVnbFhVSUVTbFRVL3FUazhINzdnbGtLYjBVa3grN0ZuVkZ1Z1VRSko3K1NKNTFCQkZKeXhucHJQMjltd1U4CkVVaTIzZXc2UjMwaUl3TUlFa2VhbmY2VjVxZ2wvTFp3UEo5N2ZsYzlaanRZUHJjc3V6M3pZOWNSOWFtK1I0aW5CWnFkRm9tVUNyeEoKWGMvdldzWXpBV1E3YmRmZnlDM3JCWktXNnpRN0xSSXgrL0pDQnUvNlJ3QzNrNSt5NjIvc1hOVDcwY3IzQ0hIMFdsYXJTSWlJamJPNQoyUE43bHZHczc3bU9aWStkZjJQbm9qN0Z3NlprdTZVWmZTMGhJdlllWmM4TTNyUEY4M3U4cWJ6ci9ZazdGL1VKUHU4K25uNnZ4YlpFCklxb3VEM3QrendJRytKNnJ5ODYvTEg3VlJ3NkxBMXZJTVQ0R2NyNTFoTkRSVlI4U0pTZnpYNC92YU12RWpLN0RUbDhlaHhmL1pmR2kKYnNYVW9ENloyRmhPRzVaYWh3Z2RGYlZFeVU4Y3hEcVA3L25JNXp0T3RsSzMrQVVLeGFjK2pndnNnNG1QbTFUVEloRzNIMy94L0o2KwpQbWNxUitmaXZ5eGUxTWY3LzRuRXpGaGV0NDRnSWxtN2lXWWUzekdjbjN6T2RHenhYK1NXOUFkU3BxMWNweC95UldLZ291Y3hkUUhQCis1enArT0svK0hXT3VvbnYvNFdJbTc1Y1p4MGhwUFNmTDRtYUFnNWpvcWQzTkdRdUZYMU10SVdhdno0QzZ0Y1I5UkdCZnpUUnRpTEIKcTR5THhFMnU1K1dvbHpEYzEwUVZhRmM4M25aSEJ2ZVp4TUlEdW5wYUpFYk9vWVBIZC9qOWRPcGlnMmVOcURPejBQZHZmVVVrV0Y2WAp2WDJmWDN6Tms2S29jemtzMEk4azZ1NW12WFVFRVhHcTg2NzNBNVpoQzIvNm1xZllMTWYyb201SmpZQS9sQ2liSHNpU1BDSVNyRDk2CmZQMnJ2cVpwVHMzdC83aTlxQThPK0FPSnRyK3gxVHFDaURoM2F2RXY4Tkx3RmJOOFRKUERRZHYvY1h0UnR6SDRVS0pxSm05WlJ4QVIKSCtSd284ZDN2TzFySGhWMUZ1N2JmVEYzRVltRjMxREgwK3NIKzVwbVJ5K3JxTDJhSGNBakRrWEVSaFV1OWZUNkw1bm5ZNXEyMi8raApxS2dyczcvSmh4SkZqMnArV2lUR2Z1ZnBBYWFGRFBVeHl5NVRINjBvWi9TaFJNMEtYcktPSUNJK09zRGpjMFRmOXpGTHZlMHJCQlFWCjlZRkdIMG4wUEJ2QXdwWWlZc25iT29xamZMMm40b0NpdnhVVmRWT2pEeVJxOG5uS09vS0krS3duVlR5OGVpT2YrSmhsMitOWGM0di8KUXNyd0h2T3RJNGlJejJwd2xxZlhmK0JqbG0yRGFCVzFGLzR2RXk4aTlucDZldlVvSDVQc1ZOUzY1aU1kOHp3dmdTa2lVWFFxZTNoNAo5WFNXK0phazJOUkhlZlkxL1ZDaTRubGRtQ2VTQ0ZVOUxWMWJ5S2UrSlNsVzFIdFIzdkl6aVloQ3JZOG9raGpuZW5yMWFOOXk3RlYwCjZYUXViTDlTVDByMU9iT3RJNGhJUUU3WmFUM1pzb3p4TFVjNTZzUDJFYldVVGVOcGtlU283K2s1ZXROWTZWdVN2VUFqNm5UbE05QTYKZ29nRTZHUVByeTNrYTk5eU5BU05xTk0xaG1YV0VVUWtRRjYrVG9UeHZ1WFlVZFI3bW40YzBmQ09kUUFSQ2RUUlZQVHc2Z20rNWRoUgoxUFdNUDVEd0syU0lkUVFSQ1ZRVlQrdklmdU5iam5wUVZOUmFMYkVzMzdEQU9vS0lCS3l6aDljdThtMXl0QVlVRlhVdDY4OGo5RDZ5CkRpQWlnZXZrNmRXVGZFcFJFelNpVG85dUhSZEpuc005dmRxdm90NHhvbFpSbDI0dFgxaEhFSkhBN1YzMFJWNmFKdnVVUWlQcU5JMWgKczNVRUVUSGc1ZXZFNlQ1bDJER2lybWI5YVlUY1dPc0FJbUxDUzFILzRGT0dhZ0M1NU9pUlRHVlFVWXNrVXhzUHIxM0dDbDh5VkFESQpMZnFibEdpemp6ZUhpa2lZdGZMMDZoOTl5VkFCb0x6RzAyWDRsZzNXRVNRaXFvYjBYTm1ET3RTaERrMW9UZ3VPcEpGMW9NaG9UaTRGCmFiLzZCNDd3SWNPMm90YUl1blI1MWdGRXNyU09kVHV0OXRtSWpwek9hZFMxRGhaNlZkalB3K09ONS9xU1FWTWZhWmxvSFVERXNRWDgKaDk0MDRIaGVZNk4xbUpBNzBNTnIvYmwvZVZ0Umw3UCtKRUx1TytzQUlyN1l5bWd1b1JHMytyamlYL1ExOGZCYWY0cTZQRUF1K2RhZgpSS2h0OWUweWRvbWZRdXNBR1ZqT1A5bWZPM3g4OEgyME5mYncydmtlWHB1K2ZJQmN0bGgvRXFFMkw2UmZENG00czU2SE9FQnJHS1ZrClA2TGVBaHBSbDhXdmk5aEZ3bVU1RjlOTDQrcmRlQmxSTC9lbFRiY1Z0VWJVcFZGUlMzSzh5Y0UrUGdBL21yd3NWRmpJLzN4SW9CRjEKR21aYUJ4QUowSHhPNEYzckVLSGliZjJyWDN4SXNLMm9DeldtTHNVODZ3QVNJVkg4TW5GWDYrbkJBT3NRSVZMTDA0SmNmaXdlc0sybwpZYTMxWnhGaWk2d0RTSVRrV0Fkd1lpdVhhcW1NSFhLbzcrSFZmaFQxR2lncTZqWFduMFdJK1hQQmpjUlRIRWJVQUZzNG55bldJVUxECnkvMmJxM3pZLzJvb0ttby9OaDRQK2I3TU9ZbUUzV3JPWjcxMWlKQ283dUcxZnN4T3JBSVZkZW1XczlVNmdvaUpxZnpST2tKSWVGbFkKeFkvWmlSMUZ2ZHI2a3dpdGxkWUJSTXc4cXlYb0FHOExxNnp6WWYrYStpaVRQaGxKcmdLdWo4MnNlemE4VEgzNE1hTGVVZFIrZkZNWgpEeXV0QTRnWXl1TWQ2d2doVU5YRGEvMTQ0TVF5S0NwcVBUdXJKTG9lUnBMdGI5WUJRc0RMMGlwKzNENjRHRlRVcGRQcTQrSkYvQ1lLCnZ1Vno2d2ptdkJTMUh4Y2ZxS2pMcEhzMkplbWVzUTVnenN2U0tuNk1xSmVBaXJwMEttcEp1aUdKWHdOR1V4K2hwNnVvSmVuV01zSTYKUW9TNGI0eDhsa05SVVMvVlhHd0p0RUs3eUh2V0FZeDVHU1c3WDlod1VkRXE2TG5BVmowanJnUXFhdkVpZmw4bUFueG1IY0NZbDZKMgozeGl6aXY2V0MrQmhRZlJrOGZLQVE1RjRQRDF2VjlNU2ZxZUZiVkhQS2ZxYmlybzBYcjd2RlltblFpWmFSekRsNVpJQzkxTWZLdW8wCmVIa2NpMGc4cHo1Z3FuVUFVMTd1Tm5RL3ROdld6VVZGUGNmNnN3aXBtdFlCUkVKZ21uVUFVMTRldE9UbGR2UDA3RlRVV3NJMXRWclcKQVVSQ1lLRjFBRk5lSGlTeGgvTzkvMWowdDZLaW5xRWxibE9xWlIxQUpBUVdXd2N3NVdVeEFDK1BSRTNINHUxZjVCWVY5U2F0dHAxUwpYVjJnSjhKUzZ3Q212SXlvWFJmMTk5di9JWGZiMzdWQ1dpcmxhR0FkUVNJa3JsOG1KbnRScnVVZVh1dTZxSGYwc29xNmRQdFlCeEF4CmwreW5mWGhaTjdXMjQzM3ZWdFRmWjdpaHVOdmJPb0JFU0R4dmVQSG5jZmhSc2Q3VHp4UDFITzk5dDZtUFpGL1NYckltMWdFa1F1STYKOVpHYi9TWWk2MmRQcjY3cmROOWJkeS9xSHozTnhDVEhnZFlCUk14VnRnNWd5TXZFQjlSM3V1K3B2MTV4c3Iyb0MvbkcraE1KSlJXMQpTQlhyQUlhOFBMQXVsenBPOS8xVjhVMm4rRTNab1lWMUFCRnpTYjVEZDRHSDE5WnovS3lQcjMvOXgxK0wra3ZqRHlTYzl2WGhYaU9KCnE3ak9VZTlsSGNDUWx4RjFJOGY3VGptaVZsR25ra3RiNndnU0dYRzk2cU9oZFFCRFhrYlUrenJkODBZbS9mcUxYNHQ2c1pZUFNPbFEKNndBaXhwcGFCekRrNWNtaWJ1KzYrS2I0eWx2Rkw3d1pZL3FCaE5VaDFnRWtNdUk2OWRIR09vQWhMdytzY3p1aS9yVDRMM0pMK2dQWgo1akRyQUNMR1dsc0hNTE9ZMVI1ZTNkanB2bmNhT0JjdjZ0R0dIMGg0SGVMOC9uMlJLS21hNE85cFpuaDZkWE9IZTg3bjgrSy9MRjdVClB5Yjh1Yk9wbGVjSTZ3Z2lobzVPOE5xaDB6MjkydVZkRjEvdi9OUytuVzhPMVpnNmxVN1dBVVFNZGJFT1lNakxvelgyZEhxOSthYzcKLzNMbm92N0U2dk1JdFk3V0FTUWk0dmxsWW5mckFJYSs4L0JhbHhNZk1Hcm5YKzVjMUIvRTlGVExUbWNxV1VlUVNJampkZFF0RXZ4VgpZZ0dUUGJ5NnBjTTlyOS8xR3J5ZGkzcFI4VXVzWlp1cW12eVF4THJNT29DaG1aNFd0ajNZNFo1SDdmb004RjBmWVBpQjBVY1NidDJzCkEwZ2t4Ty9uMFlwY2JoM0IwQmVlWHUyeXFIZnI0VjJMK24yRGp5UDhUcllPSUdMaW9rUXZSamZlMDZ0ZFhzVDQ0YTYva2JQTElLQTgKdjJqdDdSU2FNY2M2UW9URWIyU1pubklVV0Vkd2ZEelRFdjJnMzRNOXpGSHY2L0FSSEQvcy90VE9YVWZVK1pyOFNPa2M2d0FpZ2JzbQowVFc5bXFrZVh1M3lEdVpodS8vVzdvdnN2QjM0QnhJRjUxb0hrQWlJMTA4U2RmbXJkUVJUWTlqcTRkVkhPZHp6b04xL2EvZWkvaURoCmk4T24xaUhSYzNXU25uaGRudmVFODZWYW84WGJYU1h1aW5waHFrZE83MTdVNjNhZnlCYktjYjUxQkpFQTlhYVhkUVJqWG9vNmw4T2QKN1hkd3FtODZVcTB2ck1tUFZDNjJEaUFTbUVONXlqcUNzWjg5M1ZQU21ock85cHl5ZjFNVjlkQmRMN1lXNEVpdG55Z0pzUy92Sm40SgpPbTkzYVIvcmJMOUxHWnZxdDFNVjlScE5mcVIwa1hVQUNibDRmSm5ZbUZHT0g0RWZSVU05dmZwNFovc2RtUG9yek55VUwzNDF1TThqClFpNTN2TWF3U1Bqc3g2ZnNieDNDM0NaR2VIaDFqc01SZGYvVXY1MjZxSWV6UE1BUEpTb2FjYnAxQkJGZkhjbllSSytRdU4yb25aOEcKWFliV3pxNEptMWw4NWZIaVVoZjFaZ1lHK3JGRXhiWFdBU1RVb2ozMWtjT05mT1o0Z2RhbytvK25WNS9nYkwrdmxQUUhPU1djV3gwWQpGOHduRWlrRkhLQmJ5ZE1RN2NMS1hHNkVqM3hQbnVNczZ4QWhzWmtHclBUdyt2YzUxY2wrQzJuSzNOUi9sRnZDVzc3Z3h5QS9tWWpJCjVYcnJDQkppVWEzcEN0eklENnJwSFQ3MFZOTlZuWDJWT0tha21pNjVxQXQ1TWFBUEpWcXUwaU9ycEVSUnZETXhsKzVNNGxHbnkwaEYKM1J1ZVhuMENWUnp0OS9tUy95aTN4RDk1a2MwQmZDUlJVNTJyckNOSWFFVnRSRjJKM2t4aHNOTzFTYUp2R2U5NGV2MXBqdmE3UE5VegpQcllydWFpWDhxNy9uMGtFM1VBRjZ3Z2lXY3FsRTQreGdGZFUwcnQ1Z1UwZVhwM0RtWTcyKzBwcE54cm1sRElJT0pHUlFYd3VrZE9uCnRCOVJoT2lOTEYySnd0VEgzblNsSzkzMGtMRVNGTkNjV1I1ZTN6SDFuWVNlRmRLU0gwcis0OUtLT29mcGpsZldqWWU1Tk5lMFVLbFUKMUdGU25RWTBZVC8yNHlDTzBPVjNaUmpoY2VHOVI3akp5WDQvNGNUUy9yaDhLWDlXU0QvKzZmZm5Fa0ZOdUlpWHJFTklDQ1gxUDFCeAo4b3luVitmUTNkRitueTFqUjZXZVc3V1lUelUvUDVXSW1rVXJ0bGlIQ0RFVmxrVFRFaHA3K2pmN2FJOEw0SlprSHZ1VFg5b0xja3Q5CiswcGRwSmZTL3JyMlF5U0dudkU0QU92dGFMK1BsMTdUWlkyb29Ta3o5U2lpRkg3bUFFOVBBMGdXamFnbGlsYlRsUDk1ZUgxRkZsSFgKd1g3WDBMaXNXMnh5eTlqRUhGMmtsOUtlanI1Q0VKR3dlTnhUVGNPWlRtb2FYaXo3VHNpeVJ0VFFpYzk4K2xpaWJUWE5XV29kSXFRMApvcGJvV1VkVGZ2SDBqbmVkM0hhL2xSWmxYeEJZMW9nYXhqcWFMbytiR3R4dkhVRkVuSG5DWTAzdjQraWV4Q0hwWExkZGRsR2pRaXJCClpSeHBIVUZFbkZqSEl4N2YwYWZVaTV2VDkyQTZMMHFucUllVDUvaERpWWRjK3FiMStZbEkyRDNOejU1ZVg5N1JsVi9EMG12WDlJcm0KQWNjZlNsd2N6aFhXRVVRa2F5dDR5T003em5KMGorZmYwM3RaZWtVOWhLa09QNVE0ZVZpMzVJcEUzbDBzOC9pTzN6dlo3d2dtcFBmQwo5SXE2UVBQVUphakYwOVlSUkNRcjM5UFA0enNPYzdUODF2K2wrOEowNTFqZjFKaTZCR2R5a1hVRUVjbkNkV1hkRjdpYlc1M3NkeVJqCjBuMXAyZGRSYjllanRNZGFKOXB5MnVpSzZwM29PbXFKamdGYzZQRWQrekhUeVJVZnh6QSszWmVtZjlYQzJ5VXRaSjU0ZFhuY09vS0kKWkdROWYvTDhuajg0cWVraDZkZTBseEUxZE9NakIvSGk2VHdHVzBjSUVZMm9KU3Ird0tNZTM5R1EyUTVXU1N6Z1VDYWwvM0l2MXdILwpsMUV1UHBsWWV0TFJYZjhpRXB6UE12aHArSFluaTltKzVxV212WTJvNFdnK0Qra3FGdmFHY2JaR2t0dm9jNUFvV0VVNzVucDhUME5tClVUWHJQVytpRlhPOHZNSGJuWFhqZVRQcmlIRjFKcmRZUnhBUkQyN3dYTk53bTRPYWhzZTgxYlRYRVRVMFlvYVRvSEdVei9HTXN3NFIKQ2hwUlMvaTl5em1lMzlPRUdWVEtlczgvMDV4VjN0N2k5VmtWQy9oMzFqSGpxandETkZNdEVnbEw2SlBCdS83UFFVM0QzVjVyMnZ1SQpHcW94ZzcwZGhJMm45emhUNDBsOUFoSnkrWFJsdE9kM3RlTWJCNDlobTBvN3p6ZllaTERidGR5VmRkVDRPcDJiclNPSVNCbHV6cUNtCjRSOU9ucFo1by9lYXptUkVEYm1NNVJnSGdlTkpNOVVhVVV1NHZjWWxHYnpyYk41eHNPL0JuSmZKMnpJcGFqaVVyN1RrYllrV2NoUUwKclVPWVVsRkxlSDFIUjlaN2ZsZGxwdEFzNjMydm94WHpNM2xqWmtQNWIza3E2OGp4dFEvRHFHWWRRa1JTV0U3M0RHb2EvdWlncHVHKwp6R282MHhFMTFHUWFlemtJSGxmdjBwMEM2eEJtTktLV2NGclBTWHlld2Z1YU1OWEJaY2xUT1lRdG1iMDEwOG54VmZ3eDY5aHhkcmJuCkZTTkV4RjliT0Qram1vWW5uTnc5Y2wybU5aMTVVY01iakhRUVBiNyt5TlhXRVVSa2gwS3U0YjJNM25rUlp6cllmLzlzbnBXVTZkUUgKUUJPKzExeHNLZkk1alJIV0lVeG82a1BDNTQvOEs2UDMxV1VxZTJhOTkxOW93eStadnoyYjZ3TG5jbWZXOGVPc1BHL1IyanFFaUFBUApabGpUOExpRG1vYmZabFBUMlkyb0laZlA2T0RnSU9Mcko0N045SHZlQ05PSVdzTGxuOXlXNFZuWms3Y2M3SDhRUGJQYlFIWkZEUzM0Cmpzb09EaVMrZnVSWUZsdUhDSmlLV3NMa0llN0k4SjE3TThuQjgzc2NMTmFYN1MyUk03Z3Y2OE9JdHdQNFNJOXFFakZ6VDhZMW5jUHoKVHY3ZHZTbjdOVld6SFZGRGVjYm9odkl5ZkVWWFZsdUhDSkJHMUJJT2hkekNJeG0vK3pxZWNKRGhiWHBrdjVIc2l4cWE4UjNWSFJ4UQpuSDFCTjlaYWh3aU1pbHJDSUovZjhuekc3ejZZOFE0VzNmcVp0dnljL2FHNGVCclViSzF0VXFaakdLSzVmSkVBcmVHY0xHcTZHbTg1CnFPbENybkJSMDI2S0dwNWptSlB0eEZsWDNxU0NkUWlSaEpqRE1SbmUzbExrT1ZvNFNQRk1WaG1LY1RIMUFkQ0FTVTZ1Tm95M0lmUmkKazNXSUFHanFRMnlONTV5c3ZzQzdnY2NjcEpqQllSazlBQ29GTnlOcVdNb1YrdGV6VE9jeW5EMnNRNGpFM0d0MHlhcW1qK09mRGxKcwo0aUpYTmUydXFPRTlyYWFZaHE2TTBzVjZJcjdaeUUxY3dzWXN0ckF2YnptWnBMeU5QSGVINVdycUE2QUNuM0dVdTgzRjFrUk96djY2CnlsRFR6MVppWXk3bjgyVldXNmpDR0E1M2tPUmR6blg1NzRITG9vYkdmRXNkbHh1TXFUbDBaYloxQ0IrcHFNWENPMXpPeXF5MmtNUHIKOUhLUVpENkhzdHpsb2JtYitnQ1lwMGQ3cHFVcG81eDhweXdpUmRad0RlZG1XZFB3a0pPYXpxZVgyNXAyWGRRdzJNbTlQUEhYbURFYwpZaDFDSkNiR2NSajlzdDVLSDI1MWt1WlA3cGUzZGp2MUFWQ0JUK2prZXFPeHRKWmVETGNPNFF0TmZVaHdOdkJYSG5hdzhOMFpES0c4Cmd6eURPTi85dndIdWl4b2FrTWMrN2pjYlExdTVNNVpMZHFtb0pTaGp1SXFaRHJaek5DT2RYRG83Z3lQOWVLNlA2NmtQZ0tYMFpMTVAKMjQyZmNqekljN3BmVVNRank3bUc0NTNVOUVHODU2U20xOURkbjhlditWSFU4SVdlL3BHMnEzaVBXdFloUkNLbWdGZHBRVDhuUDczdAp6MGRPcmxZcjVGS20rbk80L2hRMVBFbC9uN1ljUHljeGptYldJVVFpWkJ4SDBOdlJsUlg3OFFsN085blNBd3p4NjREOW1LTXVVcEVSCkhPdlh4bU5uT1QwWWJSM0NHYzFSaTM5bWNEZURuSjFqalJqdGFKajBEajBjZktWWkF2K0tHaG93Z1NiK2JUNW1ObkU5ejFtSGNFUkYKTGY1WXlIMjhTTDZ6N2UzRHB4emdaRXZmMFlsMS9oMjRuMFVOcmZtQ0duN3VJR1plNDFvLy84OE9qSXBhM1B1WmYvR2t1OGNjQVkzNQoyRkZOTCtFbzV2bDU4UDRXTlp6S01NcjV1NHRZbWM1NVRMRU9rVFVWdGJqMU0vL21DYWNsRFUzNW1LWk90clNSTG96Mzl3UHc2OHZFCjdUN2d6ejd2SVY1YThubTJDOHVMeE1vY2ZrZGpIbkpjMDYwWjU2aW1DN25DNzVyMnY2amhIenpqK3o3aXBBWnY4YWl1clJZQjhyaVUKNWp6dGZMbU5qb3hoTDBmYitqTUQvUDhnL0o3NkFDakhRTTcxZnpleDhqVTkrY2s2Uk1ZMDlTSFoyc3gvZUpSdmZObDJkMTV6c0I1aQprWDVjRThUSEVVUlJRMVUrMFpPcVBmcUZ5M2pmT2tTR1ZOU1NqUjk0a1pmY0xBcWJ3aDk1eU5sTXdsQzZzeldJanlTWW9vWjZqS041Ck1MdUtrVmY1SFd1dFEyUkFSUzJaV2M5Z251TXozN1pmamtlNXp0bld2dWI0b0s3U0NxcW80UURHYWZsYnoyYlMyLzh2S3B4VFVZdFgKV3hsUGZ3YXd4c2Q5N01FQXpuUzJ0Ui9wd0MvK2Z6QkZnaXRxT0poUHFSM2M3bUlpbjMveGw0Zzk1RXBGTGVuTFp3eURHZWg3NlRWawptSk5GdG9vc3BETnpmRTVjVEpCRkRaMzV5TmtrZnBKOFJXK21XNGZ3UUVVdDZWalBTSVl3elBWcUtDa2R5dHZzNTJ4cnl6ak9yOGN2CnBSWnNVY05KREtOU3NMdU1oWTNjNitUaDZNRlFVVXZwWmpPY1lZek5hclZ3TDNyek5GV2RiVzBOSi9CMVFNbTNDYnFvb1JldkJYRDEKZGh6OWw2dVpheDBpTFNwcVNXMHBZeGpKY0JZRnVNL0s5T1VLaDl2YnlHbU1DakEvWUZIVWNDMVBrUlA4Ym1OZ0hYZnplRENYQTJWRgpSUzNGYmVaYnZtUUNFL2d4OEgwM1l4Q0hPdHplRnM1amFPQkhZVkxVY0FPUFdldzJGaWJTaDYrc1E1UkJSUzJ3am1sOHo3ZE00RHZuCmR4YW02M1JlZFhvQncxWXU1azJMQTdFcGFyaUpSMngySEFQNVBNV2RvYjYrV2tXZFRLdVl4MC9NWlM3VG1jSlB4dWRCT2U3bWJxZlQKckZ1NWxOZHREc2FxcU9HMldDN3JHcFNmK0IwZldJY29rWW82bVdZem5JRjhIb292dmZmalpZNXp1c1VDTHVVMXE4T3hLMnI0SXcvYgo3VHdHaG5NdEM2MURwS1NpVHJKRnZNMUF4cHJXZFUrZWRYelBSaUhYMHMvdWdDeUxHdTdtUHN2ZFI5NEsvc0l6RHRlN2NFVkZMY3Y0CmdJRjhZSEIyTnVBNWgvY2ZGaW5nR3A0UC9FaUtzUzFxamFxek40TmJlTTg2eEM1VTFGSWsrTHJ1d1RQVWM3ek5yVnpGeTRFZFFVclcKUlEzWDBsZlhWV2RwSkRlRmFsMFk4NU5LUW1VQnI5TS9nRHY1YXZJUHJuYSsxYTFjWmpjM3ZaMTlVVU1mbmxGVloya0xUL0EzVmxySAoyQ1lFSjVXRXpsVDYrL2p3VWppWjUybmtmS3VidUlCMy9meFkwaE9Hb29aZTlLZThkWWpJK3gvMzBUY1VNOWFoT0tra2hMWXlpbjY4CjYvd2hZM3Z4RUpmNGtIY1RQUmtXeEFkVGxuQVVOWnpIYTNvR2lBT1R1SVdSMWlGVTFGS3FGUXprVmNZNjJsbzVydU0rYXZpUWN6Vm4KODJtQW4wc3B3bExVMElWM2ZQbXdrMmNjZHpMYU5FRm9UaW9Kc1NuMDR4VldaYm1WOWp6TkViN2tXOHBwUGkwRmxvSHdGRFcwNXdQcQpXNGVJaVpIY2JuaVNoZWlra2xEYnlFRCt6WGNadnJzMjkvSjd5dm1TYkM3ZCtNSHNjOWxObUlvYVd2SVJqYTFEeEVRaGc3akw2RlFMCjFVa2xvVGVPSnhqazhXRmpPVnpDdzc2dEdUV1ZrMWxnL2JIc2RMZ2grM2RxWHo2a3RYV0kyTWpuRmU1alh1RDdEZGxKSlJFd2g4Zm8KeDRZMFg5MkZoM3lhOEFENG5ETllZZjJCN0N4c1JRMTFHTUt4MWlGaVpCUFBjajlMQTkxbjZFNHFpWVNmZVpySHlxeklnM21RVTMxTQpNWVNMMHY0UFJtRENWOVJRaVJlNHlEcEVyR3ppTGY3R3pNRDJGOEtUU2lKaUJRL3hlSWxGMllpN3VkS25XZWtpai9PSFVEeFVhaGRoCkxHckk0Ujd1c1E0Uk13VU01cThCM2I4WXlwTktJbU1CZitPRjNlYXM2M0FiTjFMWngvMFc4cWV3UHRNem5FVU5jQzFQNkNZWXh3b1kKeW9OTThIMC9vVDJwSkRMeXVJYThIYitxd3ZYYzRmaDVlTHZhd0VVTXNUN3Nrb1MzcU9GMEJsRGRPa1FNZmNLRGpQQjFEeUUrcVNReQpDbmllVzFsTmRYN0x6VFR3ZVc5TE9ZZngxb2Rjc2pBWE5iVGxYWnBhaDRpbHIzaUlkM3hiZlRIVUo1VkV5Q0xHMEkwNnZ1OW5JbWNaClhCM2xRYmlMR3VveWlPT3RROFRVSXA3akNaYjdzT1dRbjFRaU8zbWZYcXkyRGxHNnNCYzFWT1JwcDR1OVMzR2JlSXQvTXNueFZrTi8KVW9uc0VOTHJQSFlXL3FJR3VKbC8rSHBKVHRKOXdoTU1jemdSRW9tVFNvU045TEYvMW5RNm9sSFVjREp2QkRCVGxXUS84UlRQTzdvZgpLeUlubFNUY0FucndwWFdJOUVTbHFLRVpiOVBPT2tUTXJlY05YbkR3M1hka1RpcEpzTkdjNytNeUJvNUZwNmloTWs5em1YV0lCSmpPCnkxbXV4QkdoazhxWlRRNXV4Y2lsSm50d0lLM29RbGRxV1I5U3JQWGpPclpZaDBoZmxJb2E0Q1llMW0wd0Fkak1NRjdrb3d6bnJTTjIKVWpuaG9xaUxxOHh2dUptMjFvY1ZTK3Zwd3h2V0lieUpXbEhEOFF5Z29YV0loRmpBSzd6RUxNL3ZpOXhKNVlEcm9nWW94MlhjNzl1agpQSlBxUjg1am9uVUlyNkpYMU5DUU4raGlIU0l4Q3ZtVWwzaUhOWjdla3p4K0ZEVkFiUjd6WlRYQXBCckVsV0cvWmpxVktCWTE1SEFiCmY5Y0Zld0hheUVnR01waDFhYjA2a2lkVmx2d3Fhb0NyZU1MWGh4RWxSVDUzOFk5b25wM1JMR3FBazNoTlB4UUdiQlh2TUlDUHkxenAKUExJblZSYjhMR280bEVFMHN6N0VpSnZEQlh4bEhTSlQwUzFxMkpzQldtTEF3QzhNNUUzR2xYSTNWNFJQcW96NVc5UlFoOWM1eGZvZwpJK3hkTGcvYnFpMWVSTG1vb1J4M2NyZXVBakV4bjdjWXhKY3A2enJTSjFXRy9DNXF5T1d2M0dWOW1KRzBnVnQ1S3RwblpiU0xHdUJJCjNtQi82eENKdFl3UEdNWUhyTjNwZHlOL1VtWEEvNklHNk1QVCttN0dvNmxjR0wyclBIWVYvYUtHbWp4Tkwrc1FpYmFPRHhuS2V6dWUKeEJlRGs4cXpZSW9hZWpKQVZaMjJRdnB5S3h1dFkyUXZEa1VOMEpOK3VwUEwyRmJHTTR4M21hNmk5bFVmK2xrZmJFVDh3cFVNc3c3aApSbHlLR3ByeENwMnNRd2p3UFFkWlJ6QVFYRkhEQTl4aGZiZ1JNSncrTExFTzRVcDhpaHJLY1F2M1VjazZoaVJTa0VXZHk5dWNiWDNBCm9iYUdtM25lT29STGNTcHFnRGIwNXpEckVKSkFRUlkxVkdVMGgxc2ZjbWg5UVc5K3RBN2hWcTUxQU1lbWNBejNsM2xEaG9ock9ZSHUKYlQwOTR2Tmp2Vk1idVpWT2NhdnArSTJvaXh6RkM3U3hEaUdKRXV5SUd1QTRQdGIxSDd1WXdKVk1zUTdoaDdpTnFJdE00RkR1WUxOMQpEQkVmamVidjFoRkNaUU4zMERHZU5SM1hFWFdSZHJ5bytXb0pTUEFqYXNqbHY1eG9mZUFoTVo1TDRqZmg4YXQ0anFpTFRPUW83b2pECnhlNGlLUlZ3a1dhcXQxa1E1NXFPOTRpNlNFdWU0VGpyRUJKN200MHVERDJWOXdMK0lqT3N1dkt4ZFFUL3hIbEVYV1E2WGJoaXg4M04KSXY2d0d2Rjh3RlBXaHg0U1QxREJPb0ovNGwvVVVNaExIRWkvUk43WUxQRjNHejlZUndpRlZseHZIY0UvOFovNitGVVhucWFGZFFpSgpLYXVwRDRCaitFd1g2Z0ZyYU1raTZ4RCtTTUtJZXJ0UnRPTnUxbHZIRUhIc1MwMS9BRkNkQjZ3aitDVkpJK29pamZrM1BheERTT3dFCk42S3VRU1AyWm04YXNSZjdzaGVOYUtEeDlEYUZkR2FjZFFnL0pLK29BYnJ5T0syc1EwaXN1Qy9xR3RTbkh2V29SMTNxc2VlMnYrL0wKSHRhSEdtcmZjZ1JiclVPNGw4eWloZ3JjeUYrb2JoMURZc05yVWU5Qk5XcFFnMXJVb0RvMXFFNU5hbTM3cHpyVXBSNFZyUThwb243SAowOVlSM0V0cVVRUHN4Zjl4V2FKbTZjVS9XN21UcXNYS3VoSlZBYWhGRGpYSnBRYmxxRUU1cWxPZWFuRytrTXpjQ3BxenpEcUVhMGt1CmFvRFcvRXRyTzR2RXlyTmNheDNCdGFRWE5VQlhIcU8xZFFnUmNhU0FZL2pTT29SYitzRWZSbklvdDdEQ09vYUlPSkZMMzdnMVc4d08KSjBPYitUZjc4eEFicklPSWlBT0hjNmwxQkxjMDlWRmNJKzdtU2wyVEtoSjVQOU9DbGRZaDNOR0l1cmdGWEVOYkJsckhFSkVzN2NtOQoxaEZjMG9nNmxjNzhuYzdXSVVRa0MvbTBaNUoxQ0ZjMG9rN2xNNDZsTTJPc1k0aEl4c3JUTno1UDZsWlJsMlFzeDNFU2VkWXhSQ1JECm5iakFPb0lybXZvb1hRNDl1RmNybW90RTBrSmFzdFk2aEFzYVVaZXVrRUVjekZrYVdZdEUwRDdjYVIzQkRZMm8wNVBER2R6RmtkWXgKUk1TVHpSek1ET3NRMmRPSU9qMkZET01vT2pQS09vaUllRkNSSjZ3anVLQ2k5bUlzSjlDVmtkWXhSQ1J0SjNHMmRZVHNhZW9qRSsyNApoVjZVdDQ0aEltbVlSNnVvTDhHbkVYVW1KdEtiNWp3ZTlmL3pSUktoTWJkYVI4aVdSdFRaYU1BTlhFc2Q2eGdpVXFvTnRHR09kWWhzCnFLaXpWWWtMdUYzUHN4WUp0YmVqdmFTMWl0cUZIRTdrUms2UHp3MnJJckZ6R2g5WVI4aWNpdHFkdHR6RWhWUzJqaUVpS2N5a0xadXMKUTJSS1h5YTZNNWtyMll1Ym9qMFhKaEpUQjNLamRZVE1hVVR0WGk0bmNEWGR0UUNCU0tpc3BTVUxyVU5rUmtYdGx3TzRpcXVvYXgxRApSSFo0ZzR1c0kyUkdSZTJuU3B6RjFaeW9MeGxGUXFJTG4xcEh5SVNLMm44dHVKd3JxRzhkUTBTWXdpSGtXNGZ3VGtVZGpFcDBwdy9ICmEyd3RZdXlHS0Q2bVNVVWRwSDI1a0Q3c2J4MURKTUZXMDRJbDFpRzhVbEVITFpjT1hNS0ZWTE1PSXBKUUwzQ1ZkUVN2Vk5RMnFuRWUKbDlGWjE3R0xCSzZBRGt5d0R1R05pdHJTUHB4SFR6cGF4eEJKbUR5T3BNQTZoQmNxYW51dHVJQUxPZEE2aGtpQzlPRjU2d2hlcUtqRApJWWRqK0EwOTJOczZpRWdpTEtjRnk2MURwRTlGSFNhNWRLQW5QZGpIT29oSTdEM0o5ZFlSMHFlaURoL1Z0WWovdG5JNDMxbUhTSmVLCk9xeHlPWVp6T0ljRHJJT0l4TlE0T2hPUkFsUlJoMTB6enFRbkhYUlBvNGh6Ri9PNmRZVDBxS2lqb1JGbmN4YkhVY2s2aUVpTUxLRWwKcTZ4RHBFTkZIU1ZWNmNDWm5NdSsxa0Vrd3VZd2toTnBaaDBqSkI3bU51c0k2VkJSUjA4T2gzQWFaM0NrN21zVUQvTDVqUGQ1ajJuQQphYnhuSFNja3R0Q09hZFloeXFhaWpxNjZuRUJYVHFhSmRSQUp1ZG1NWkNRaldGbnM5ejZoaTNXc2tQaVlydFlSeXFhaWpyNW1kS1VyCjNhaHBIVVJDWmkzakdjN1FsS3Q0SHNsNGZVRzlUUS9ldG81UUZoVjFYRlRrYUU2Z0MwZnBDOGZFVzhjNFJqR0tyOWxheXF2ZTVTenIKb0NFeG4xYXNzdzVST2hWMTNGU2hQUjNwU21jVmR1TGtNNUdSak9Rek5xWHg2cFpNcHJ4MTVKQzRqM3VzSTVST1JSMVgxZWhFSnpwegpCRldzbzRqUDF2QUY0eGpEZURaNmV0L0xYR29kUFNRMjBaYVoxaUZLbzZLT3UvSzBveE1kNlVJOTZ5amkyRksrWWl6aitKTE5HYjIvCkNUUDBjOWMyUXpuYk9rSnBWTlJKa1VOcmp1Rm9qcUsxTHV1THRId21NWjRKZk9GZ0RQZ0lOMWtmVG1pY0VlWkxGbFhVeVZPTlEyaFAKUjQ2bGdYVVU4V0F4ZWVReGxzOVo3MnliOVpoRkRlc0RDNGxadEVscmJ0K0VpanJKOXFQOXRyL3FXa2VSRWl6bUcvTElJNCtGdm16LwpIdTYxUHNUUStETVBXRWNvaVlwYW9LaXlENk05aDJpVUhRcnorVzViUVMveWVVL1YrRkgvbjIrem50Yk10UTZSbW9wYWRsYWJOclNuCk5XMDRUTmVMQkdvTE04bGpDbE9ad004Qjd2ZEdIclUrOU5ENEQ3K3hqcENhaWxwS1VvR1dITVJCdEtRTisrdUtXMTlzWmdiVG1NcFUKSmpPejFOdFQvRk9SYVhwRTB3NG44b2wxaEZSVTFKS09palNuRmExcFRRc09wS3AxbkVoYnpVeG1NSVhwZk05czhxM2pBTDE1eFRwQwphRXpsRUxaWWg5aWRpbHE4cTAwejJ0Q2FaalNqbFdxN1RKdFp3R3ltTW9YWnpHWk82RllWeWVVYjJsbUhDSTAvaEhFcVNFVXQyYXBOCnMySi9OYUdjZGFBUVdNSHNZbi9OTlpyVVNOK1pETFdPRUJxcmFjbGk2eEM3VWxHTFd4VnBITzZiY1gxU3lKTXNZQ0h6bU0rQ1VFeG8KZVBNcHgxbEhDSTJYdWR3NndxNVUxT0plRWsrcWZDcFlSOGhLSno2empoQWFoUndYdGs5RE54T0xDSXdOOHczVUFjdmhzYkJONEttbwpSUVRnVHhSWVJ3aU5RK2xqSFdGbm12b1E5NUo0VWtWOTZnUGdWUzYyamhBYS82TUZ5NnhEL0VvamFoRXBjbmQ0SDBvVXVEcmNaeDJoCk9CVzFpQlQ1aVg3V0VVTGtHbzZ3anZBclRYMkllMGs4cWVJdzlRSDFtVVYxNnhDaDhRVWR3M0l1YTBRdDRrSThWdlQrSll4MzVaazUKaHQ3V0ViYlRpRnJjUytKSnRUVW1qNjJxem8vc2FSMGlOSmJTa3BYV0lVQWphaEVwYmcwUFdVY0lrUWI4eFRwQ0VZMm94YjBrbmxSeApHVkZEUmFiVDFEcEVhT1J6R0pPdFEyaEVMU0k3Mjh6ZnJDT0VTSG42aHVIN0I0Mm94YjBrbmxUeEdWRkRPU2JTeGpwRWlGekFXOVlSClZOVGlYaEpQcWpnVk5aekwyOVlSUW1RQnJWaHJHMEZUSHlLeXF5RjhiaDBoUkJyeEorc0lHbEdMZTBrOHFlSTFvb2JPakxHT0VDS2IKYWNzUGxnRTBvaGFSM1gzR2g5WVJRcVFpVDlnRzBJaGEzRXZpU1JXM0VUVWN6TGNheUJWekZzUHNkcTcvSTBRa2xVbjh4enBDcUR4SwpaYnVkcTZoRkpMVTcyV3dkSVVTYWNhdmR6bFhVSXBMYUhGNndqaEFxZjJJL3ExMXJqbHJjUytKSkZiODVhb0M5bU1rZTFpRkNaRERuCjJleFlJMm9SS2NsaUhyT09FQ285T01WbXh4cFJpM3RKUEtuaU9hS0dtc3lpcm5XSUVKbEpXNHNGeXpTaUZwR1NyZEpqVDNkeUlOZGIKN0ZZamFuRXZpU2RWWEVmVVVKa2YyTmM2Uklpc29TV0xndDZwUnRRaVVwcU40VnFQMjF4MWk1OHhOS0lXOTVKNFVzVjNSQTNsbUV3cgo2eEFoVWtnWFJnZTdTNDJvUmFSMFc4T3lJRlZJNVBCazBQOVpWbEdMU0ZrR005NDZRcWdjeERYQjdsQlRIK0plRWsrcUFzcFpSL0RWCmNYeHFIU0ZVVnRDQ1g0TGJuVWJVSWxLMjBZeXdqaEFxdGZsN2tMdlRpRnJjUytKSkZmY1JOYlRucXpBczh4b2FCWFJnUWxBNzA0aGEKUk5LUngwRHJDS0dTUzkvZytsTkZMU0xwdVlzdDFoRkNwVDJYQmJVckZiV0lwR2NtTDFsSENKa0hxQlhNamxUVUlwS3VlMWx2SFNGVQo5dVN2d2V4SVJTMGk2VnBzdmNocjZQeWVka0hzUmxkOWlIdEpQS25pZjlWSGtWck1vbzUxaUZBWnk3SCtuL0VhVVl0SStsYnlzSFdFCmtPbkViL3pmaVViVTRsNFNUNnFraktpaENqL1F5RHBFcUN5aEJhdjkzWVZHMUNMaXhZWmc3OG1MZ0liODJlOWRhRVF0N2lYeHBFck8KaUJyS001bVcxaUZDWlRQdG1PN25EalNpRmhGdjhyblhPa0xJVlBUN2FoaU5xTVc5Sko1VVNScFJRdzVmMGQ0NlJNaDBaNGgvRzFkUgppM3RKUEttU1ZkVFFqWStzSTRUTVBGcjVkenVRcGo1RXhMdi84ckYxaEpCcHpHMytiVndqYW5FdmlTZFYwa2JVY0FRVDlOalRuV3lnCkRYUDgyYlJHMUNLU2lhLzhuSk9OcENyODI2OU5hMFF0N2lYeHBFcmVpQnFhTXlYR2E2OW41blRlOTJPekdsR0xTR1orNEJYckNLSHoKR0pYODJLeUtXa1F5ZFk4ZWU3cUxBN2pKajgycXFFVWtVd3Q1eWpwQzZQeUZ4dTQzcWpscWNTK0pKMVZoUWdjOXRabEZiZXNRSVRPQQpDMTF2TXBrbmw0aTRzWUovV1VjSW5WNTBjYjFKamFqRnZTU2VWRWtkVWNNZS9FaEQ2eEFoTTRWRDNTNEVuTlNUUzBUY1dNZi9XVWNJCm5UYjh6dTBHTmFJVzk1SjRVaVYzUkEwVm1Nb0IxaUZDWmpVdFdleHVjOGs5dVVURWpTM2NZeDBoZEdxNC9UbERJMnB4TDRrblZaSkgKMUpCREhvZGFod2laUWpvdzN0WEdrbnh5aVlnYmhkeHBIU0YwY3VqcjdyRUNLbW9SeWQ0SGpMS09FRHFIY2FXclRXbnFROXhMNGttVgo3S2tQZ0NNWnI4ZWU3dUovdEdDWml3MGwvZVFTRVRlK1pLaDFoTkNwdzEvZGJFZ2phbkV2aVNlVlJ0VFFndS8xMk5OZEZIQVVYMmUvCkdaMWNJdUxHREY2empoQTZ1VHptWWtKSUkycHhMNGtubFViVUFFMlk0Yy96bUNPdE42OW11d21kWENMaXlsdzk5alNGaDZtWjdTWlUKMUNMaXp2MnN0bzRRT2cyNE85dE5xS2hGeEoxbGV1eHBDamZTTnJzTmFJNWEzRXZpU2FVNTZ1MnE4U01OckVPRXpzZDB6ZWJ0T3JsRQp4S1cxM0c4ZElZUk81THhzM3E0UnRiaVh4Sk5LSStwZlZXUXErMXVIQ0ozNXRHSmRwbS9XeVNVaWJtMTJkVDllck96TEhabS9XU05xCmNTK0pKNVZHMU1YbGtzY2gxaUZDWnpOdCtTR3p0K3JrRW5GQmp5TXFyb0MvV0VjSW9ZcVpYeEdqRWJXSStLRzI4ZjRMV0dYOUViaWoKb2hZUkNibi9COEVEK0RkNElkSHFBQUFBQUVsRlRrU3VRbUNDIiAvPgo8L3N2Zz4K" id="front-cover-1-pagedown-attachment" rel="attachment" />
<link href="data:image/jpeg;base64,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" id="front-cover-2-pagedown-attachment" rel="attachment" />
<link href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI3MjRweCIgaGVpZ2h0PSI1NjFweCIgdmlld0JveD0iMCAwIDcyNCA1NjEiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDcyNCA1NjEiIHhtbDpzcGFjZT0icHJlc2VydmUiPiAgPGltYWdlIGlkPSJpbWFnZTAiIHdpZHRoPSI3MjQiIGhlaWdodD0iNTYxIiB4PSIwIiB5PSIwIgogICAgaHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUF0UUFBQUl4Q0FRQUFBREhyZWRLQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk4KQUFCNkpnQUFnSVFBQVBvQUFBQ0E2QUFBZFRBQUFPcGdBQUE2bUFBQUYzQ2N1bEU4QUFBQUFtSkxSMFFBLzRlUHpMOEFBRUh5U1VSQgpWSGphN2QxM21CWGwzY2J4N3k0ZDZVVlFFUVNWS3FKaXBhZ29ZbThnR2l4WVVaUFlvckVrYWpUbWpTVW1zV0xCamdVaklBcllBb29nCktLaXJBdEpFUURvb2hONlgzZmVQQlZ6ZzdPNlpjNTZaMzVUNzQ1VkxnWE5tN2prWmI1OTl6c3c4T1lXSWlFaVk1Vm9IRUJHUjBxbW8KUlVSQ3JyeDFBSkZkVktmbXRyK3FVWTFLMUtRcWxhaE5KYXF5QnhYSm9SWlFtU3BBeldKRGpXcFUyR2s3bTFtMzQ1L3pXUU9zWXpPRgpyQVEyc29HMWJHSVZHOWpJU2pheGp0V3NZaldyV01WYTY0OUFaR2M1bXFNV0E3V29UejNxYnZ1ckh2V29TdzFxVW51bjZyV3lsVldzClpDV3JXTVl5bHUvNGF4ay9zOFk2bkNTUmlscjhWWTZHTkdGUDltWlBHcklYZTdJUGUxTEpPbGJHTnJDRXhmek1JbjVtTVV0WXdueVcKVW1BZFMrSk5SUzF1TmFBcCs3SVBUZGlIZldoQ1E4cFpSL0xkRmhZeG4va3NaRDd6bWM5UExMT09KUEdpb3BiczFLQVpUV2xLVS9hagpLVTJwYWgwb0ZOWXdoem44eEJ4bTh4T3ppODJXaTJSQVJTMWVWV0lmMnRDYVpqU2pHVTNKc1E0VUFTdVl6VlNtTUp2WlRGZHRpMWNxCmFrbEhmZHJRaXRhMG9nV05yTU5FWEFIem1jRVVwakdWcWF5d2ppTlJvS0tXa3RTaEhXMXBUU3ZhVU5jNlRHd3RZU3JUbU1Ka0pyUEsKT295RWxZcGFpaXRQWTlyUW52YTAxcVJHNEJZemhhbmtrY2QwdGxxSGtUQlJVUXRVb2kzdGFVOTcya1Q0d3JrNFdjOGs4dmlHUEthUQpieDFHN0ttb2s2c2k3VGlNOXJTbjdTNzM5RWw0YkdRaWVlU3BzcE5OUlowOGU5T2VqblRpTUtwWVJ4RVAxdkVkZWVUeEdYT3NvMGpRClZOUkpVWlVqNmNCUkhFVUQ2eWlTcGZtTVp6emorWnJOMWxFa0dDcnF1S3ZCa1hTaUk1MDEreHc3VzVqRVNNWXhWaGY1eFoyS09xNzIKb1F1ZDZFd3JYYnNSZTF1WnhHZDh4bWgrc1k0aS9sQlJ4ODJlSEVjbk9uS1lDanFCWmpPU2tYekNjdXNnNHBhS09pNXEwNFV1bkVCcgo2eUJpcm9EdkdNVW9SdXZKMm5HaG9vNjZjaHhDVjdweW5DNnhrMTNrTTVHUkRPZHpQWVkxNmxUVTBkV01yblNsSzdXdGcwaklMV01VCkkvbVFlZFpCSkZNcTZ1Z3B4ekdjUVZmYVd3ZVJpSm5OY0lZeG1pM1dRY1FyRlhXVTFPZFV6cUFiTmEyRFNJVDlqNDhaeVZDV1dBZVIKOUttb28rRVF6dVlzRHRXVkhPTElWc1l6bEhmNHdUcUlwRU5GSFc1RjB4em4wdHc2aU1UVWJJWXpVRjgzaHAyS09xeXEwSTF6T0lONgoxa0VrQVJZeWxIY1lwZG5yc0ZKUmgwOWxUcUluWjFQRE9vZ2t6QXFHTTVDUDlBU1I4RkZSaDRrcVd1eXBya05JUlIwT0ZUbVZYcHpCCkh0WkJSQUJZd1R1OHdTaXROQk1PS21wcnVYU2dKNzJvYngxRVpEZkxHY3lyakVNMVlVeEZiYWtOUGJtRVp0WXhSRW8xbHpkNWlSblcKTVpKTVJXMWpMeTdpTXRwWXh4Qkoyd1Q2TTBCUHZyYWhvZzVhSmJweENlZm9FVW9TUVpzWVFYL2UwV1Y4UVZOUkI2azl2YmxRVjBaTAp4QzFtSUMveG5YV01KRkZSQjZNbUYvQTcybG5IRUhFbWozNjhvU2RlQjBORjdiLzJYTTNGVkxXT0llTGNHZ2J3S21PdFk4U2ZpdHBQCjllbE5IMXBZeHhEeDFUYzh4eHVzdG80Ulp5cHF2N1RuYWk2aGluVU1rVUNzNVEzNk1zazZSbHlwcU4ycnhGbmNSQWZyR0NLQnkrTngKQnVpYUVQZFUxRzd0VHgrdTFIVWRrbUJMZUlXK3pMZU9FUzhxYW5jNmNRUGRLV2NkUThUY1ZqN2dmcjZ3amhFZkttb1hLbkkydDNDVQpkUXlSVU1uamNkNGczenBHSEtpb3MxV2ZLN2lPUnRZeFJFSnBEcy9TVHplZVowdEZuWTBEdVlWTHFXd2RReVRVVnZNY2o3RFFPa2FVCnFhZ3pkU2gvb0JmbHJXT0lSTUlXM3VRaHBsakhpQ29WZFNZNmNUdG5XSWNRaVpoQzN1TkJ4bG5IaUNJVnRUZmxPSi9iOWN3T2tZeU4KNVVIZTExSUUzcWlvMDVkTEQrNmpwWFVNa2NpYnhMOTRqUUxyR05HaG9rNVBCWHB4SjgydFk0akV4dmM4ek90YWt6RTlLdXF5VmVKSwpicWV4ZFF5UjJKbkcvUXhRV1pkTlJWMjZDdlRpWHBwYXh4Q0pyVGs4eUFzcTY5S3BxRXVXU3cvdTV3RHJHQ0t4TjVXSE5HZGRHaFYxCmFybjA0UDgwSnkwU21PKzVqMEc2R2lRMUZmWHVjamlYKzdSQ3VFamdKdkJuUHJFT0VVWXE2bDBkelQvb2JCMUNKTEZHY2p2ZldJY0kKbTF6ckFLSFNpcmY0UWpVdFlxZ3JYL01XKzF2SENCZU5xTGRyeE4xY3FhZEppNFRDRmw3aUx5eTFqaEVXS21xQTZ2eUptN1Mrb1VpbwpyT0lCSG1XVGRZd3dVRkhuY2pFUDBkQTZob2lrTUorN2VGWFhnaVM5cUUvZ1h4eGlIVUpFU3ZFbGYrQno2eEMya3Z4bFlndUc4ckZxCldpVGtqdVF6K3JPUGRReExTUjFSVitVMjdxQ1NkUXdSU2RONkh1YUJwTTVZSjdPb3orUkpQV1JKSkhKKzVFYmV0dzVoSVhsRjNZTEgKNldZZFFrUXlOSndibUdNZEltakptcU91d2FOOHI1b1dpYkF6bU1LOVNWdFNPa2tqNmpQcHk3N1dJVVRFZ1ZuOG5vK3NRd1FuS1NQcQpmUmpNVU5XMFNFenN6NGU4eFo3V01ZS1NoS0l1ejQxTXA3dDFEQkZ4cWljenVERVJIWmFBcVkrajZNZkIxaUZFeENkanVZYXAxaUg4CkZ1Ly9HbFhoUWNhcHBrVmlyQlBmOFNBVnJXUDRLODRqNm82OFFBdnJFQ0lTZ01sY3dkZldJZndUMXhGMVZSNWtqR3BhSkNIYThnVVAKeHZkZTQzaU9xRS9pT1pwWWh4Q1JnRTNsU3NaYmgvQkQvRWJVVlhpUUQxWFRJZ25VbXJIeEhGZkhiVVI5Tks5bzdYQ1JSUHVlM254cgpIY0t0T0kyb0szQXZZMVhUSWdsM0VCTzROMTdMNnNWblJIMEkvV2xySFVKRVFtSWNsekxMT29RcjhSaFI1M0FqNDFYVElySkRSeVp6Cm8zVUlWK0l3b3Q2VGx6ak5Pb1NJaE5CZytyRENPa1Qyb2wvVTNYaVp2YXhEaUVoSXplTmlQck1Pa2Exb1QzMVU1akUrVkUyTFNJa2EKTTRvSHFXQWRJenRSSGxFMzV5M2FXWWNRa1FnWVF5OFdXWWZJWEhSSDFPY3lRVFV0SW1rNWxvbWNZaDBpYzlFczZrbzh4dHZVc280aApJcEZSai9kNU1LcFhWMGR4NnFNSi8rRW82eEFpRWtHZmNpR0xyVU40RjcwUjlibE1WRTJMU0VhTzV4dU90UTdoWGJTS09vZmJHVVJOCjZ4Z2lFbGtOK1pqYnJVTjRGYVdwanhyMDUyenJFQ0lTQXdPNGl2WFdJZElYbmFJK21DRTBzdzRoSWpFeGtlN010ZzZScnFoTWZmVGkKQzlXMGlEalRqaS9wWmgwaVhWRW82aHp1NVhXcVdzY1FrVmlweS90Um1hME8vOVJITmZwenJuVUlFWW1wRi9nZG02MURsQ1hzUmQySQpkem5NT29TSXhOZzR1dk96ZFlqU2hidW9PL0EyRGF4RGlFak16ZVlzcGxpSEtFMlk1Nmg3ODRscVdrUjgxNHpQdy8wa2tQQVc5WTI4CkhNZlZoRVVraEdvd25OOWFoeWhaT0tjK0t2QU1WMWlIa01RcVlCWHIyTUJxMXJLZXRheG02N2JmTGJKdTI1ZFBXMW05N1hlcUZYdmUKY1htcTcvam5HcFNqT3VXcFJnWDJvQ0pWcVVRVktsT1pLdFlIS1NuOG5ic0paU1dHc2Fpck15ZzYxemRLSksxbE9iK3dqT1VzWi9tMgp2NjlrQXh0WXdYbzJCWktoSnRXcFRnMnFVNXNhMi82NUJyV29RVTNxVVY5UGh6VHhHbGVHOFJxUThCWDFQcnluNTB5TE0xdFl3bndXCnNwRDVMR0xKdG1vT3BvcXpVNEY2MUtVZTlhbS83Wi9xMFpBRyt0N0daNlBvemtyckVMc0tXMUczNEw4MHRnNGhrVlhBQXVZd2o0VXMKWWg2TFdNQlNDcXhET1ZhUnZXakUzdXhOSXhxeUwzdlJTTGVET1RXWlU4SzJHa3k0aXZwdzNxZStkUWlKbE0zOHhDeG1NWXNmbWNYcwpTSXlWM2F2RlBqU2o2WTcvN1dFZEtPTG1jREl6clVNVUY2YWlQcEVoeGI2R0VVbXRrTGxNWWRxMmFwN0hWdXRBSWJSbnNkcmVYeitqClptQXBwL0t0ZFloZmhhZW96K1pOS2x1SGtOQmF3VlNtTUpVOEpyTEdPa3pFVk9JQVd0T0cxalNqamY0dFM5TmF1alBDT3NSMllTbnEKcTNrcXFxdVppVzlXOHgxVG1jUlVKdk0vNnpBeFVZRURhRVZMV3RPU2czU25RcWsyOGh2ZXRRNVJKQnhGL1Z2NmttTWRRa0ppTTVNWgpSeDU1VEl2ZEY0SGhVcDRXdEtZTjdUbEszdzJsdEpYTGVkVTZCSVNqcUcvakllc0lZbTRMTThramp6eStET04xckxHM04rMXBUMnZhCjBFcURwbUsyMG9lWHJFT0VvYWp2NVI3ckNHSm9ObU1aeDFkOHp4YnJLQUpBUFk3bUtEcHdoTDdhQjZDQTM5TFBPb1IxVWQvSDNkWWYKZ1ppWXpVakdNWWFmcklOSUNjclJrdlowcEJNdFEveE1vQ0FVY2pPUDJrYXdMZXBIdU1uMjhDVmdtL21henhqTDJQRGQreVVscXN2UgpIRVVuamtud0ZTTzM4ay9MM1ZzVzlUKzV4ZkxRSlVENWZNa0lSdkVsRzZ5alNNWXFjd3hkT0lFaml6MkNLamx1NWhHN25kc1Y5ZC81CnM5MWhTMkJtTTVLUmpHU0ZkUkJ4cGlvZDZFcW5oQlYySVRmeWhOWE9yWXBhTlIxM0svaUVFWXhndG5VUThVMHRqdU1FVHVWQTZ5QUIKS2VUM1BHMnphNXVpL2l0L3NUbGM4VjBCRS9pQUVYeWxXN3NUb3ptbmN6ckhKbUI4WGNnMVBHZXhZNHVpL2pOL3R6aFU4ZGtHUHVaZApockhVT29pWXFFRTNUdU8wbUQrR3RZREw2Ui84Ym9NdjZ0L3lWUENIS2I1YXhuQ0c4bC9XV1FjUmM3a2N6dW1jVG52cklMN0o1N3pnCmJ5d1B1cWd2NU5XRVg1TVpMM01ZeGpCRzYyWVYyVVZqenFVbkhXSjVsK05tenVLallIY1piRkdmenBBRXpHTWx3M1RlWkJCVHJHTkkKcURYamZIcHltSFVNNTliUWxTK0QzR0dRUlgwTUkvUkE4eGlZenhBR010WTZoa1JHRTg2aEp4MnRZemkxa3VPWkdOenVnaXZxZG95bQpabkFISmo1WXdrRGU1SXR3cnRNc0lkZWNDN2lVL2Exak9MT1FEc3dMYW1kQkZmVStmTUcrUVIyVU9MZVNZUXprQS9LdGcwakV0ZWRxCkxxU2FkUXducHRJcHFCdTVnaW5xV295bFRUQUhKSTdsOHo0djhLRWVQU3JPVktjbmw5TXhCbDgwZnNvcHdhelNHVVJSVitSOVRnemkKWU1TeEh4akFpOEg5ZUNlSjBwd0x1WlQ5ckdOazZTMTZCYkc4aGY5Rm5jTWIvTWIvQXhHbjFqR0lGeGlyMldqeFZUbTY4WHRPamZRbAp1dzl6bS84NzhiK29IK0FPL3c5REhKckFpN3pKYXVzWWtoZ0hjQjJYVThNNlJzWis1LzhUUVB3dTZrc3NicmVVREszaVpaN25lK3NZCmtrRFY2YzMxdExDT2taRjhUdUZqZjNmaGIxRjM0Qk90Y3h3Uk0rbkxDNnkxamlHSjFva2I2RTQ1NnhpZXJlQm9mdkJ6QjM0V2RSTW0KeFB3QkxmRlF3SHM4enNlYWo1WlFPSkFidUlLcTFqRTgrb0dqL2J4VXo3K2lyc1pZMnZrWFhKeFl6WnM4d25UckdDSTdxYy92dVpGYQoxakU4R2NOSi9sM0U2bGRSNXpDWWMvMEtMVTVNNFVsZTFSUHZKS1JxY3dNM1VNYzZoZ2RQY3IxZm0vYXJxUFhNNlhBYnhZT00wR1NICmhGeDFmc3ZORVpwQXZkU3ZpeWY4S2VxdWZCakJMd1NTb1pEM3VKOHZyR09JcEtrU2wzSlhSQjVBc1pGTzVQbXhZVCtLdWlsZlIrb0gKbHVUSTUwMGUxS05KSlhJcWNpMTNVZDg2UmhybWNEai9jNzlaOTBWZG1iRXhYdDBodWpiekgvN0dUT3NZSWhuYWcrdTRrK3JXTWNvMAprbFBjcnhmcS90Yk5aMVhUb2JPYWgyaE1iOVcwUk5nNkhxSWwvVUwvQk1ldTNPdCtvNjVIMUpmellpQWZocVJyTFkveHI2QWV4aWppCnUxYmN6em5XSVVwVndDbU1jTHRKdDBYZG5LOGo4S05KY216bVplNWxzWFVNRWNlTzRoOGNheDJpRkQ5ektJdGNidEJsVVZkbXZHNXgKQ1kwQ0JuTUhzNjFqaVBqa1RKNmlrWFdJRW4xS1Y1Y3oxUzducUI5WFRZZEVJUU5weGZtcWFZbXhZUnpFNCs2L3RuUGtlUDdzY25QdQpSdFMvWVVEd240YWtNSXk3bUdRZFFpUVFoL0UwUjFxSFNHa3JKekRHMWNaY0ZYVmpKa2JzenZ4NEdzL051cGxGRWlXWFB0d2Z5anMzCjVuRXdxMXdkcEp1dHZLU2FOcmVJYStpb21wYUVLZUJaRHVUeElCYkU4cWd4VDdyYWxKc1I5UzM4MCs3VEVHQUQvK1FoUFdCSkV1eDQKWHFTcGRZamRYTUJiTGpiam9xamI4RFdWclQrUFJCdk9EY3l4RGlGaXJDb1BjSDNJMWpaZnljSE16MzR6MlU5OVZPSjExYlNoYnppTwpNMVhUSXF6blJrNWxvWFdNbmRUaVJSZi82Y2krcU8vUlJYbG1mdVpLam5EM3piSkk1SDFFT3daYWg5aEpWNjdOZmlQWlRuMjA0eXNxCldIOFNpVlRJYTl6TU11c1lJaUhVazZlcGF4MWloM1cwemZabjN1eEcxT1Y1U1RWdFlnWmQ2SzJhRmtscElPMzRyM1dJSGZiZ3FXdzMKa1YxUjM4NmgxcDlCQW0zaElRNWh0SFVNa1JCYnlDbmNFWnI3RmsvaDB1dzJrTTNVUnd1KzA5ZUlnUnZITlhyMHYwaGF1akFnSkF0NQpyYUpOTmw5elpqNml6dVVGMVhUQVZuSU5uVlhUSW1rYXhSRk1zQTRCUUUwZXkrYnRtUmYxRlhTMFB2YUVHVUlyK21sQldoRVA1bk1zCmZhMURBTkNEVXpOL2M2WlRIM1dZUVQzckkwK1ExZHhLUCtzUWFhdHRIVUFDdElHTjFoSEtkQ0g5Mk1NNkJMTTRLTlBQS3RPaWZwNHIKclk4NlFjWndLVDlaaC9CQW8vNWsyY1FxVnJLS0pTeGdNZk5ZeER4bXM4VTYxazRPNG0wT3RBN0JmZHlUMlJzeksrcU9mQmF5R3pYagphd3YzODdmUWZIdWRIaFcxNURPSDZjeGdCak9ZRm9vTFNldndEcDJOTTJ5aUhUTXllV01tUlYyZVBBNDJQdUNrbU16RkVYeTJ0SXBhCmRyYVlQUExJWXp5L0dLYW96S3VjWi94SmZNUXBtYnd0azZLK25zZU5EellaQ25tQzI5aGtIU09qNUNLcHplSnJ2bUk4WDVwTWplUncKVDZhVEQ4NmN3N3NaQlBmODcxUnRab2JvNXN6NFdzUkZmR29kSWtNcWFpbkxPajduVXo3bFMvSUQzdk4xUEVvNXd5T2Z5VUZzOXZvbQo3MFg5Q0RjWkhtUlNqT1kzTExFT2tURVZ0YVJySGFNWXh2c3NDSENmSnpPUTZvYkhmQXYvOXZvV3IwWGRuTWxVTkR6RUpDamdmdTZOCjJOZUhPMU5SaXplRmZNczdER1pxUVBzN2ttSHNhWGEwS3puUTY5ZXJYb3Q2S0dlYUhWNHlMS2MzNzF1SHlKS0tXakl6bmJjWnhMY0IKN0trNUk5blg3RGo3Y3AyM04zZ3I2aTU4WW5ab3lmQWw1elBYT2tUV1ZOU1NqZW44aDFkOFh3eGpQejZtbWRFUjV0T1c2VjdlNEsybwpQK2NZb3dOTGhuNWM3LzFyaGhCU1VVdTJDaGhGZndheDNzZDlOR1FFQnhrZDN5QjZlbm01bDZJK2h5RkdCNVVFNjdpS042MURPS0tpCkZqZFc4UitlNEh2ZnR0K0FVYlF5T2JKQ2p1VHI5RitlZmxIbjhvMFczZkxOWXM3eThuOWJ5S21veFoxQ1B1WnBodnAwR1o5ZFZYdTYKOVNYOW9yNkUvaWFIa3dTVE9KTjUxaUVjVWxHTGF6L3hLTS81TWhIU2lFL1ozK1NZVG1CVXVpOU50NmdyTXMxczRqM3UzdVVpMWxtSApjRXBGTFg3NGhhZDRuUDg1MzI0VHh0RFk0SGkrb0VPNkwwMzNlZFNYcWFaOThqamRZMWJUSXY2b3p6Mzh4SVBVY2J6ZHVYUmxxY0h4CkhKUCs1RWQ2SStweVRBdkJJd0xqSjUrYlF2SlFjN2Mwb2hZL3JhVXZEN0RLNlRhUDRCT3FCWDRrYVkrcDB4dFJYNmlhOXNFS1RvbGwKVFl2NHF4cTNNNHZicWVKd20xL1IzZURTMkdQb2t0NEwweGxSNS9LOTBmZWljYmFRYm9IZE1CczBqYWdsQ0hPNWhjRU90OWVibHdOLwp6djdIZEUzblplbU1xSHVvcHAyYnczR3hyV21SWURSaEVKODR2R1dsUC84WCtER2NtTjdhcyttTXFML2xrTURqeDl2M2RHT3hkUWdmCmFVUXR3ZG5DMDl6TmFpZmJ5dUYxZWdXYy96M09TQ05ZbWY5T2RXVkV3TUhqN2t0TzllRVNvekJSVVV1d0ZuRXR3NXhzcVRLZkJQeWcKakVJT0t2dW42N0tuUG00T05IVDhqZWFrbU5lMFNORDJaaWh2T1ZuUVpDUGRXUmhvOXB4MG52QmYxb2k2QlZQVHZ0WmF5amFjODlsZwpIY0ozR2xHTGhTVmNtOGt5VjdzNW1rK3BGR0R1VFRRcDZ6cnVza3I0RnRXMFE2OXpiZ0pxV3NSR1E5N2hSUWRydDR6bnhrQnpWK0xxCnNsNVMrb2k2UG5PZFhxdVliRzl5Y2FUWGJVbWZSdFJpNXdkNk1pbnJyYnpNcFFGbVhzSitwUzlqWGZwNCtSclZ0RE5ENloyUW1oYXgKMUp3SjlNbDZLNzluV29DWkczSkI2UzhvYlVTZHkyeWFCQmcyemo3bUREWmFod2lNUnRSaTdWV3V6ZkpaZXdjeGdhcUI1ZjI4OU91cApTeHRSbjZxYWRtUXNaeVdvcGtYc1hjTG5XZmJYOS93aHdMd2RPTGkwUHk2dHFLOEpNR2FjZmNkWnZpNG9KQ0s3YThkNGpzaHFDLzJjCjNxQmVsbEsvVUN4NTZxTVJQMUV1d0poeE5aa3VMTGNPRVRCTmZVZzRyT09pckM3WXE4OWtHZ1NVZFEzN3NLYWtQeXg1UkgyVmF0cUIKbVhSTFhFMkxoTVVlRE9hR0xONy9TNER6Q3RWTCswS3hwQkYxTG5OTTFqeUlsMlVjdzQvV0lReG9SQzFoOGlnM1ozRk92c1JsQWVVYwpYL0xONnlVVjlRbDhIRkM0K05yQ3llbXZpUllyS21vSmx4ZTRtb0lNMzF1VHFld2RVTTZXekVqOUJ5Vk5mVndTVUxENEt1VEtoTmEwClNOaGNTYitNNzdGZUZlRFZIeGVWOUFlcFI5UlZXRXpOd01MRjAzM2NZeDNCakViVUVqNHYwaWZqVWZVUXpna2s0MXlhcHY2M0ovVi8KWmM1UlRXZnBUZTYxamlBaXhWekI4eG1QcXE5bmJTQVptOUFwOVIra0RxNkpqK3g4d2VVYVZZcUV6T1U4bGVFN0Z3UzI5a3NKM1p0cQo2cU11U3lnZlVLdzRtc1BSL0d3ZHdwVCtJeVZoOVNjZXpPaDlGWmxNOHdEeS9ZK0diTm45dDFPTnFNOVdUV2RoRStjbHZLWkZ3dXYrCkRPY0xObk45SVBucWNIeXEzMDVWMU9jR0VpaXVidUViNndnaVVvSWNudWZFak43NVg5NFBKR0dQbExGMyt5bTFPajlUT1pCQWNUU0kKbnRZUlFrQlRIeEptcStqTTVBemUxNHBKQWN3MkxHTXY4bmY5emQxSDFHZXBwak0yaTZ1c0k0aElHV3J5THJVemVOODArZ2VRcmw2cQpCNTd1WHRTYStNalVKaTVnbFhVSUVTbFRVL3FUazhINzdnbGtLYjBVa3grN0ZuVkZ1Z1VRSko3K1NKNTFCQkZKeXhucHJQMjltd1U4CkVVaTIzZXc2UjMwaUl3TUlFa2VhbmY2VjVxZ2wvTFp3UEo5N2ZsYzlaanRZUHJjc3V6M3pZOWNSOWFtK1I0aW5CWnFkRm9tVUNyeEoKWGMvdldzWXpBV1E3YmRmZnlDM3JCWktXNnpRN0xSSXgrL0pDQnUvNlJ3QzNrNSt5NjIvc1hOVDcwY3IzQ0hIMFdsYXJTSWlJamJPNQoyUE43bHZHczc3bU9aWStkZjJQbm9qN0Z3NlprdTZVWmZTMGhJdlllWmM4TTNyUEY4M3U4cWJ6ci9ZazdGL1VKUHU4K25uNnZ4YlpFCklxb3VEM3QrendJRytKNnJ5ODYvTEg3VlJ3NkxBMXZJTVQ0R2NyNTFoTkRSVlI4U0pTZnpYNC92YU12RWpLN0RUbDhlaHhmL1pmR2kKYnNYVW9ENloyRmhPRzVaYWh3Z2RGYlZFeVU4Y3hEcVA3L25JNXp0T3RsSzMrQVVLeGFjK2pndnNnNG1QbTFUVEloRzNIMy94L0o2KwpQbWNxUitmaXZ5eGUxTWY3LzRuRXpGaGV0NDRnSWxtN2lXWWUzekdjbjN6T2RHenhYK1NXOUFkU3BxMWNweC95UldLZ291Y3hkUUhQCis1enArT0svK0hXT3VvbnYvNFdJbTc1Y1p4MGhwUFNmTDRtYUFnNWpvcWQzTkdRdUZYMU10SVdhdno0QzZ0Y1I5UkdCZnpUUnRpTEIKcTR5THhFMnU1K1dvbHpEYzEwUVZhRmM4M25aSEJ2ZVp4TUlEdW5wYUpFYk9vWVBIZC9qOWRPcGlnMmVOcURPejBQZHZmVVVrV0Y2WAp2WDJmWDN6Tms2S29jemtzMEk4azZ1NW12WFVFRVhHcTg2NzNBNVpoQzIvNm1xZllMTWYyb201SmpZQS9sQ2liSHNpU1BDSVNyRDk2CmZQMnJ2cVpwVHMzdC83aTlxQThPK0FPSnRyK3gxVHFDaURoM2F2RXY4Tkx3RmJOOFRKUERRZHYvY1h0UnR6SDRVS0pxSm05WlJ4QVIKSCtSd284ZDN2TzFySGhWMUZ1N2JmVEYzRVltRjMxREgwK3NIKzVwbVJ5K3JxTDJhSGNBakRrWEVSaFV1OWZUNkw1bm5ZNXEyMi8raApxS2dyczcvSmh4SkZqMnArV2lUR2Z1ZnBBYWFGRFBVeHl5NVRINjBvWi9TaFJNMEtYcktPSUNJK09zRGpjMFRmOXpGTHZlMHJCQlFWCjlZRkdIMG4wUEJ2QXdwWWlZc25iT29xamZMMm40b0NpdnhVVmRWT2pEeVJxOG5uS09vS0krS3duVlR5OGVpT2YrSmhsMitOWGM0di8KUXNyd0h2T3RJNGlJejJwd2xxZlhmK0JqbG0yRGFCVzFGLzR2RXk4aTlucDZldlVvSDVQc1ZOUzY1aU1kOHp3dmdTa2lVWFFxZTNoNAo5WFNXK0phazJOUkhlZlkxL1ZDaTRubGRtQ2VTQ0ZVOUxWMWJ5S2UrSlNsVzFIdFIzdkl6aVloQ3JZOG9raGpuZW5yMWFOOXk3RlYwCjZYUXViTDlTVDByMU9iT3RJNGhJUUU3WmFUM1pzb3p4TFVjNTZzUDJFYldVVGVOcGtlU283K2s1ZXROWTZWdVN2VUFqNm5UbE05QTYKZ29nRTZHUVByeTNrYTk5eU5BU05xTk0xaG1YV0VVUWtRRjYrVG9UeHZ1WFlVZFI3bW40YzBmQ09kUUFSQ2RUUlZQVHc2Z20rNWRoUgoxUFdNUDVEd0syU0lkUVFSQ1ZRVlQrdklmdU5iam5wUVZOUmFMYkVzMzdEQU9vS0lCS3l6aDljdThtMXl0QVlVRlhVdDY4OGo5RDZ5CkRpQWlnZXZrNmRXVGZFcFJFelNpVG85dUhSZEpuc005dmRxdm90NHhvbFpSbDI0dFgxaEhFSkhBN1YzMFJWNmFKdnVVUWlQcU5JMWgKczNVRUVUSGc1ZXZFNlQ1bDJER2lybWI5YVlUY1dPc0FJbUxDUzFILzRGT0dhZ0M1NU9pUlRHVlFVWXNrVXhzUHIxM0dDbDh5VkFESQpMZnFibEdpemp6ZUhpa2lZdGZMMDZoOTl5VkFCb0x6RzAyWDRsZzNXRVNRaXFvYjBYTm1ET3RTaERrMW9UZ3VPcEpGMW9NaG9UaTRGCmFiLzZCNDd3SWNPMm90YUl1blI1MWdGRXNyU09kVHV0OXRtSWpwek9hZFMxRGhaNlZkalB3K09ONS9xU1FWTWZhWmxvSFVERXNRWDgKaDk0MDRIaGVZNk4xbUpBNzBNTnIvYmwvZVZ0Umw3UCtKRUx1TytzQUlyN1l5bWd1b1JHMytyamlYL1ExOGZCYWY0cTZQRUF1K2RhZgpSS2h0OWUweWRvbWZRdXNBR1ZqT1A5bWZPM3g4OEgyME5mYncydmtlWHB1K2ZJQmN0bGgvRXFFMkw2UmZENG00czU2SE9FQnJHS1ZrClA2TGVBaHBSbDhXdmk5aEZ3bVU1RjlOTDQrcmRlQmxSTC9lbFRiY1Z0VWJVcFZGUlMzSzh5Y0UrUGdBL21yd3NWRmpJLzN4SW9CRjEKR21aYUJ4QUowSHhPNEYzckVLSGliZjJyWDN4SXNLMm9DeldtTHNVODZ3QVNJVkg4TW5GWDYrbkJBT3NRSVZMTDA0SmNmaXdlc0sybwpZYTMxWnhGaWk2d0RTSVRrV0Fkd1lpdVhhcW1NSFhLbzcrSFZmaFQxR2lncTZqWFduMFdJK1hQQmpjUlRIRWJVQUZzNG55bldJVUxECnkvMmJxM3pZLzJvb0ttby9OaDRQK2I3TU9ZbUUzV3JPWjcxMWlKQ283dUcxZnN4T3JBSVZkZW1XczlVNmdvaUpxZnpST2tKSWVGbFkKeFkvWmlSMUZ2ZHI2a3dpdGxkWUJSTXc4cXlYb0FHOExxNnp6WWYrYStpaVRQaGxKcmdLdWo4MnNlemE4VEgzNE1hTGVVZFIrZkZNWgpEeXV0QTRnWXl1TWQ2d2doVU5YRGEvMTQ0TVF5S0NwcVBUdXJKTG9lUnBMdGI5WUJRc0RMMGlwKzNENjRHRlRVcGRQcTQrSkYvQ1lLCnZ1Vno2d2ptdkJTMUh4Y2ZxS2pMcEhzMkplbWVzUTVnenN2U0tuNk1xSmVBaXJwMEttcEp1aUdKWHdOR1V4K2hwNnVvSmVuV01zSTYKUW9TNGI0eDhsa05SVVMvVlhHd0p0RUs3eUh2V0FZeDVHU1c3WDlod1VkRXE2TG5BVmowanJnUXFhdkVpZmw4bUFueG1IY0NZbDZKMgozeGl6aXY2V0MrQmhRZlJrOGZLQVE1RjRQRDF2VjlNU2ZxZUZiVkhQS2ZxYmlybzBYcjd2RlltblFpWmFSekRsNVpJQzkxTWZLdW8wCmVIa2NpMGc4cHo1Z3FuVUFVMTd1Tm5RL3ROdld6VVZGUGNmNnN3aXBtdFlCUkVKZ21uVUFVMTRldE9UbGR2UDA3RlRVV3NJMXRWclcKQVVSQ1lLRjFBRk5lSGlTeGgvTzkvMWowdDZLaW5xRWxibE9xWlIxQUpBUVdXd2N3NVdVeEFDK1BSRTNINHUxZjVCWVY5U2F0dHAxUwpYVjJnSjhKUzZ3Q212SXlvWFJmMTk5di9JWGZiMzdWQ1dpcmxhR0FkUVNJa3JsOG1KbnRScnVVZVh1dTZxSGYwc29xNmRQdFlCeEF4CmwreW5mWGhaTjdXMjQzM3ZWdFRmWjdpaHVOdmJPb0JFU0R4dmVQSG5jZmhSc2Q3VHp4UDFITzk5dDZtUFpGL1NYckltMWdFa1F1STYKOVpHYi9TWWk2MmRQcjY3cmROOWJkeS9xSHozTnhDVEhnZFlCUk14VnRnNWd5TXZFQjlSM3V1K3B2MTV4c3Iyb0MvbkcraE1KSlJXMQpTQlhyQUlhOFBMQXVsenBPOS8xVjhVMm4rRTNab1lWMUFCRnpTYjVEZDRHSDE5WnovS3lQcjMvOXgxK0wra3ZqRHlTYzl2WGhYaU9KCnE3ak9VZTlsSGNDUWx4RjFJOGY3VGptaVZsR25ra3RiNndnU0dYRzk2cU9oZFFCRFhrYlUrenJkODBZbS9mcUxYNHQ2c1pZUFNPbFEKNndBaXhwcGFCekRrNWNtaWJ1KzYrS2I0eWx2Rkw3d1pZL3FCaE5VaDFnRWtNdUk2OWRIR09vQWhMdytzY3p1aS9yVDRMM0pMK2dQWgo1akRyQUNMR1dsc0hNTE9ZMVI1ZTNkanB2bmNhT0JjdjZ0R0dIMGg0SGVMOC9uMlJLS21hNE85cFpuaDZkWE9IZTg3bjgrSy9MRjdVClB5Yjh1Yk9wbGVjSTZ3Z2lobzVPOE5xaDB6MjkydVZkRjEvdi9OUytuVzhPMVpnNmxVN1dBVVFNZGJFT1lNakxvelgyZEhxOSthYzcKLzNMbm92N0U2dk1JdFk3V0FTUWk0dmxsWW5mckFJYSs4L0JhbHhNZk1Hcm5YKzVjMUIvRTlGVExUbWNxV1VlUVNJampkZFF0RXZ4VgpZZ0dUUGJ5NnBjTTlyOS8xR3J5ZGkzcFI4VXVzWlp1cW12eVF4THJNT29DaG1aNFd0ajNZNFo1SDdmb004RjBmWVBpQjBVY1NidDJzCkEwZ2t4Ty9uMFlwY2JoM0IwQmVlWHUyeXFIZnI0VjJMK24yRGp5UDhUcllPSUdMaW9rUXZSamZlMDZ0ZFhzVDQ0YTYva2JQTElLQTgKdjJqdDdSU2FNY2M2UW9URWIyU1pubklVV0Vkd2ZEelRFdjJnMzRNOXpGSHY2L0FSSEQvcy90VE9YVWZVK1pyOFNPa2M2d0FpZ2JzbQowVFc5bXFrZVh1M3lEdVpodS8vVzdvdnN2QjM0QnhJRjUxb0hrQWlJMTA4U2RmbXJkUVJUWTlqcTRkVkhPZHp6b04xL2EvZWkvaURoCmk4T24xaUhSYzNXU25uaGRudmVFODZWYW84WGJYU1h1aW5waHFrZE83MTdVNjNhZnlCYktjYjUxQkpFQTlhYVhkUVJqWG9vNmw4T2QKN1hkd3FtODZVcTB2ck1tUFZDNjJEaUFTbUVONXlqcUNzWjg5M1ZQU21ock85cHl5ZjFNVjlkQmRMN1lXNEVpdG55Z0pzUy92Sm40SgpPbTkzYVIvcmJMOUxHWnZxdDFNVjlScE5mcVIwa1hVQUNibDRmSm5ZbUZHT0g0RWZSVU05dmZwNFovc2RtUG9yek55VUwzNDF1TThqClFpNTN2TWF3U1Bqc3g2ZnNieDNDM0NaR2VIaDFqc01SZGYvVXY1MjZxSWV6UE1BUEpTb2FjYnAxQkJGZkhjbllSSytRdU4yb25aOEcKWFliV3pxNEptMWw4NWZIaVVoZjFaZ1lHK3JGRXhiWFdBU1RVb2ozMWtjT05mT1o0Z2RhbytvK25WNS9nYkwrdmxQUUhPU1djV3gwWQpGOHduRWlrRkhLQmJ5ZE1RN2NMS1hHNkVqM3hQbnVNczZ4QWhzWmtHclBUdyt2YzUxY2wrQzJuSzNOUi9sRnZDVzc3Z3h5QS9tWWpJCjVYcnJDQkppVWEzcEN0eklENnJwSFQ3MFZOTlZuWDJWT0tha21pNjVxQXQ1TWFBUEpWcXUwaU9ycEVSUnZETXhsKzVNNGxHbnkwaEYKM1J1ZVhuMENWUnp0OS9tUy95aTN4RDk1a2MwQmZDUlJVNTJyckNOSWFFVnRSRjJKM2t4aHNOTzFTYUp2R2U5NGV2MXBqdmE3UE5VegpQcllydWFpWDhxNy9uMGtFM1VBRjZ3Z2lXY3FsRTQreGdGZFUwcnQ1Z1UwZVhwM0RtWTcyKzBwcE54cm1sRElJT0pHUlFYd3VrZE9uCnRCOVJoT2lOTEYySnd0VEgzblNsSzkzMGtMRVNGTkNjV1I1ZTN6SDFuWVNlRmRLU0gwcis0OUtLT29mcGpsZldqWWU1Tk5lMFVLbFUKMUdGU25RWTBZVC8yNHlDTzBPVjNaUmpoY2VHOVI3akp5WDQvNGNUUy9yaDhLWDlXU0QvKzZmZm5Fa0ZOdUlpWHJFTklDQ1gxUDFCeAo4b3luVitmUTNkRitueTFqUjZXZVc3V1lUelUvUDVXSW1rVXJ0bGlIQ0RFVmxrVFRFaHA3K2pmN2FJOEw0SlprSHZ1VFg5b0xja3Q5CiswcGRwSmZTL3JyMlF5U0dudkU0QU92dGFMK1BsMTdUWlkyb29Ta3o5U2lpRkg3bUFFOVBBMGdXamFnbGlsYlRsUDk1ZUgxRkZsSFgKd1g3WDBMaXNXMnh5eTlqRUhGMmtsOUtlanI1Q0VKR3dlTnhUVGNPWlRtb2FYaXo3VHNpeVJ0VFFpYzk4K2xpaWJUWE5XV29kSXFRMApvcGJvV1VkVGZ2SDBqbmVkM0hhL2xSWmxYeEJZMW9nYXhqcWFMbytiR3R4dkhVRkVuSG5DWTAzdjQraWV4Q0hwWExkZGRsR2pRaXJCClpSeHBIVUZFbkZqSEl4N2YwYWZVaTV2VDkyQTZMMHFucUllVDUvaERpWWRjK3FiMStZbEkyRDNOejU1ZVg5N1JsVi9EMG12WDlJcm0KQWNjZlNsd2N6aFhXRVVRa2F5dDR5T003em5KMGorZmYwM3RaZWtVOWhLa09QNVE0ZVZpMzVJcEUzbDBzOC9pTzN6dlo3d2dtcFBmQwo5SXE2UVBQVUphakYwOVlSUkNRcjM5UFA0enNPYzdUODF2K2wrOEowNTFqZjFKaTZCR2R5a1hVRUVjbkNkV1hkRjdpYlc1M3NkeVJqCjBuMXAyZGRSYjllanRNZGFKOXB5MnVpSzZwM29PbXFKamdGYzZQRWQrekhUeVJVZnh6QSszWmVtZjlYQzJ5VXRaSjU0ZFhuY09vS0kKWkdROWYvTDhuajg0cWVraDZkZTBseEUxZE9NakIvSGk2VHdHVzBjSUVZMm9KU3Ird0tNZTM5R1EyUTVXU1N6Z1VDYWwvM0l2MXdILwpsMUV1UHBsWWV0TFJYZjhpRXB6UE12aHArSFluaTltKzVxV212WTJvNFdnK0Qra3FGdmFHY2JaR2t0dm9jNUFvV0VVNzVucDhUME5tClVUWHJQVytpRlhPOHZNSGJuWFhqZVRQcmlIRjFKcmRZUnhBUkQyN3dYTk53bTRPYWhzZTgxYlRYRVRVMFlvYVRvSEdVei9HTXN3NFIKQ2hwUlMvaTl5em1lMzlPRUdWVEtlczgvMDV4VjN0N2k5VmtWQy9oMzFqSGpxandETkZNdEVnbEw2SlBCdS83UFFVM0QzVjVyMnZ1SQpHcW94ZzcwZGhJMm45emhUNDBsOUFoSnkrWFJsdE9kM3RlTWJCNDlobTBvN3p6ZllaTERidGR5VmRkVDRPcDJiclNPSVNCbHV6cUNtCjRSOU9ucFo1by9lYXptUkVEYm1NNVJnSGdlTkpNOVVhVVV1NHZjWWxHYnpyYk41eHNPL0JuSmZKMnpJcGFqaVVyN1RrYllrV2NoUUwKclVPWVVsRkxlSDFIUjlaN2ZsZGxwdEFzNjMydm94WHpNM2xqWmtQNWIza3E2OGp4dFEvRHFHWWRRa1JTV0U3M0RHb2EvdWlncHVHKwp6R282MHhFMTFHUWFlemtJSGxmdjBwMEM2eEJtTktLV2NGclBTWHlld2Z1YU1OWEJaY2xUT1lRdG1iMDEwOG54VmZ3eDY5aHhkcmJuCkZTTkV4RjliT0Qram1vWW5uTnc5Y2wybU5aMTVVY01iakhRUVBiNyt5TlhXRVVSa2gwS3U0YjJNM25rUlp6cllmLzlzbnBXVTZkUUgKUUJPKzExeHNLZkk1alJIV0lVeG82a1BDNTQvOEs2UDMxV1VxZTJhOTkxOW93eStadnoyYjZ3TG5jbWZXOGVPc1BHL1IyanFFaUFBUApabGpUOExpRG1vYmZabFBUMlkyb0laZlA2T0RnSU9Mcko0N045SHZlQ05PSVdzTGxuOXlXNFZuWms3Y2M3SDhRUGJQYlFIWkZEUzM0Cmpzb09EaVMrZnVSWUZsdUhDSmlLV3NMa0llN0k4SjE3TThuQjgzc2NMTmFYN1MyUk03Z3Y2OE9JdHdQNFNJOXFFakZ6VDhZMW5jUHoKVHY3ZHZTbjdOVld6SFZGRGVjYm9odkl5ZkVWWFZsdUhDSkJHMUJJT2hkekNJeG0vK3pxZWNKRGhiWHBrdjVIc2l4cWE4UjNWSFJ4UQpuSDFCTjlaYWh3aU1pbHJDSUovZjhuekc3ejZZOFE0VzNmcVp0dnljL2FHNGVCclViSzF0VXFaakdLSzVmSkVBcmVHY0xHcTZHbTg1CnFPbENybkJSMDI2S0dwNWptSlB0eEZsWDNxU0NkUWlSaEpqRE1SbmUzbExrT1ZvNFNQRk1WaG1LY1RIMUFkQ0FTVTZ1Tm95M0lmUmkKazNXSUFHanFRMnlONTV5c3ZzQzdnY2NjcEpqQllSazlBQ29GTnlOcVdNb1YrdGV6VE9jeW5EMnNRNGpFM0d0MHlhcW1qK09mRGxKcwo0aUpYTmUydXFPRTlyYWFZaHE2TTBzVjZJcjdaeUUxY3dzWXN0ckF2YnptWnBMeU5QSGVINVdycUE2QUNuM0dVdTgzRjFrUk96djY2CnlsRFR6MVppWXk3bjgyVldXNmpDR0E1M2tPUmR6blg1NzRITG9vYkdmRXNkbHh1TXFUbDBaYloxQ0IrcHFNWENPMXpPeXF5MmtNUHIKOUhLUVpENkhzdHpsb2JtYitnQ1lwMGQ3cHFVcG81eDhweXdpUmRad0RlZG1XZFB3a0pPYXpxZVgyNXAyWGRRdzJNbTlQUEhYbURFYwpZaDFDSkNiR2NSajlzdDVLSDI1MWt1WlA3cGUzZGp2MUFWQ0JUK2prZXFPeHRKWmVETGNPNFF0TmZVaHdOdkJYSG5hdzhOMFpES0c4Cmd6eURPTi85dndIdWl4b2FrTWMrN2pjYlExdTVNNVpMZHFtb0pTaGp1SXFaRHJaek5DT2RYRG83Z3lQOWVLNlA2NmtQZ0tYMFpMTVAKMjQyZmNqekljN3BmVVNRank3bUc0NTNVOUVHODU2U20xOURkbjhlditWSFU4SVdlL3BHMnEzaVBXdFloUkNLbWdGZHBRVDhuUDczdAp6MGRPcmxZcjVGS20rbk80L2hRMVBFbC9uN1ljUHljeGptYldJVVFpWkJ4SDBOdlJsUlg3OFFsN085blNBd3p4NjREOW1LTXVVcEVSCkhPdlh4bU5uT1QwWWJSM0NHYzFSaTM5bWNEZURuSjFqalJqdGFKajBEajBjZktWWkF2K0tHaG93Z1NiK2JUNW1ObkU5ejFtSGNFUkYKTGY1WXlIMjhTTDZ6N2UzRHB4emdaRXZmMFlsMS9oMjRuMFVOcmZtQ0duN3VJR1plNDFvLy84OE9qSXBhM1B1WmYvR2t1OGNjQVkzNQoyRkZOTCtFbzV2bDU4UDRXTlp6S01NcjV1NHRZbWM1NVRMRU9rVFVWdGJqMU0vL21DYWNsRFUzNW1LWk90clNSTG96Mzl3UHc2OHZFCjdUN2d6ejd2SVY1YThubTJDOHVMeE1vY2ZrZGpIbkpjMDYwWjU2aW1DN25DNzVyMnY2amhIenpqK3o3aXBBWnY4YWl1clJZQjhyaVUKNWp6dGZMbU5qb3hoTDBmYitqTUQvUDhnL0o3NkFDakhRTTcxZnpleDhqVTkrY2s2Uk1ZMDlTSFoyc3gvZUpSdmZObDJkMTV6c0I1aQprWDVjRThUSEVVUlJRMVUrMFpPcVBmcUZ5M2pmT2tTR1ZOU1NqUjk0a1pmY0xBcWJ3aDk1eU5sTXdsQzZzeldJanlTWW9vWjZqS041Ck1MdUtrVmY1SFd1dFEyUkFSUzJaV2M5Z251TXozN1pmamtlNXp0bld2dWI0b0s3U0NxcW80UURHYWZsYnoyYlMyLzh2S3B4VFVZdFgKV3hsUGZ3YXd4c2Q5N01FQXpuUzJ0Ui9wd0MvK2Z6QkZnaXRxT0poUHFSM2M3bUlpbjMveGw0Zzk1RXBGTGVuTFp3eURHZWg3NlRWawptSk5GdG9vc3BETnpmRTVjVEpCRkRaMzV5TmtrZnBKOFJXK21XNGZ3UUVVdDZWalBTSVl3elBWcUtDa2R5dHZzNTJ4cnl6ak9yOGN2CnBSWnNVY05KREtOU3NMdU1oWTNjNitUaDZNRlFVVXZwWmpPY1lZek5hclZ3TDNyek5GV2RiVzBOSi9CMVFNbTNDYnFvb1JldkJYRDEKZGh6OWw2dVpheDBpTFNwcVNXMHBZeGpKY0JZRnVNL0s5T1VLaDl2YnlHbU1DakEvWUZIVWNDMVBrUlA4Ym1OZ0hYZnplRENYQTJWRgpSUzNGYmVaYnZtUUNFL2d4OEgwM1l4Q0hPdHplRnM1amFPQkhZVkxVY0FPUFdldzJGaWJTaDYrc1E1UkJSUzJ3am1sOHo3ZE00RHZuCmR4YW02M1JlZFhvQncxWXU1azJMQTdFcGFyaUpSMngySEFQNVBNV2RvYjYrV2tXZFRLdVl4MC9NWlM3VG1jSlB4dWRCT2U3bWJxZlQKckZ1NWxOZHREc2FxcU9HMldDN3JHcFNmK0IwZldJY29rWW82bVdZem5JRjhIb292dmZmalpZNXp1c1VDTHVVMXE4T3hLMnI0SXcvYgo3VHdHaG5NdEM2MURwS1NpVHJKRnZNMUF4cHJXZFUrZWRYelBSaUhYMHMvdWdDeUxHdTdtUHN2ZFI5NEsvc0l6RHRlN2NFVkZMY3Y0CmdJRjhZSEIyTnVBNWgvY2ZGaW5nR3A0UC9FaUtzUzFxamFxek40TmJlTTg2eEM1VTFGSWsrTHJ1d1RQVWM3ek5yVnpGeTRFZFFVclcKUlEzWDBsZlhWV2RwSkRlRmFsMFk4NU5LUW1VQnI5TS9nRHY1YXZJUHJuYSsxYTFjWmpjM3ZaMTlVVU1mbmxGVloya0xUL0EzVmxySAoyQ1lFSjVXRXpsVDYrL2p3VWppWjUybmtmS3VidUlCMy9meFkwaE9Hb29aZTlLZThkWWpJK3gvMzBUY1VNOWFoT0tra2hMWXlpbjY4CjYvd2hZM3Z4RUpmNGtIY1RQUmtXeEFkVGxuQVVOWnpIYTNvR2lBT1R1SVdSMWlGVTFGS3FGUXprVmNZNjJsbzVydU0rYXZpUWN6Vm4KODJtQW4wc3B3bExVMElWM2ZQbXdrMmNjZHpMYU5FRm9UaW9Kc1NuMDR4VldaYm1WOWp6TkViN2tXOHBwUGkwRmxvSHdGRFcwNXdQcQpXNGVJaVpIY2JuaVNoZWlra2xEYnlFRCt6WGNadnJzMjkvSjd5dm1TYkM3ZCtNSHNjOWxObUlvYVd2SVJqYTFEeEVRaGc3akw2RlFMCjFVa2xvVGVPSnhqazhXRmpPVnpDdzc2dEdUV1ZrMWxnL2JIc2RMZ2grM2RxWHo2a3RYV0kyTWpuRmU1alh1RDdEZGxKSlJFd2g4Zm8KeDRZMFg5MkZoM3lhOEFENG5ETllZZjJCN0N4c1JRMTFHTUt4MWlGaVpCUFBjajlMQTkxbjZFNHFpWVNmZVpySHlxeklnM21RVTMxTQpNWVNMMHY0UFJtRENWOVJRaVJlNHlEcEVyR3ppTGY3R3pNRDJGOEtUU2lKaUJRL3hlSWxGMllpN3VkS25XZWtpai9PSFVEeFVhaGRoCkxHckk0Ujd1c1E0Uk13VU01cThCM2I4WXlwTktJbU1CZitPRjNlYXM2M0FiTjFMWngvMFc4cWV3UHRNem5FVU5jQzFQNkNZWXh3b1kKeW9OTThIMC9vVDJwSkRMeXVJYThIYitxd3ZYYzRmaDVlTHZhd0VVTXNUN3Nrb1MzcU9GMEJsRGRPa1FNZmNLRGpQQjFEeUUrcVNReQpDbmllVzFsTmRYN0x6VFR3ZVc5TE9ZZngxb2Rjc2pBWE5iVGxYWnBhaDRpbHIzaUlkM3hiZlRIVUo1VkV5Q0xHMEkwNnZ1OW5JbWNaClhCM2xRYmlMR3VveWlPT3RROFRVSXA3akNaYjdzT1dRbjFRaU8zbWZYcXkyRGxHNnNCYzFWT1JwcDR1OVMzR2JlSXQvTXNueFZrTi8KVW9uc0VOTHJQSFlXL3FJR3VKbC8rSHBKVHRKOXdoTU1jemdSRW9tVFNvU045TEYvMW5RNm9sSFVjREp2QkRCVGxXUS84UlRQTzdvZgpLeUlubFNUY0FucndwWFdJOUVTbHFLRVpiOVBPT2tUTXJlY05YbkR3M1hka1RpcEpzTkdjNytNeUJvNUZwNmloTWs5em1YV0lCSmpPCnkxbXV4QkdoazhxWlRRNXV4Y2lsSm50d0lLM29RbGRxV1I5U3JQWGpPclpZaDBoZmxJb2E0Q1llMW0wd0Fkak1NRjdrb3d6bnJTTjIKVWpuaG9xaUxxOHh2dUptMjFvY1ZTK3Zwd3h2V0lieUpXbEhEOFF5Z29YV0loRmpBSzd6RUxNL3ZpOXhKNVlEcm9nWW94MlhjNzl1agpQSlBxUjg1am9uVUlyNkpYMU5DUU4raGlIU0l4Q3ZtVWwzaUhOWjdla3p4K0ZEVkFiUjd6WlRYQXBCckVsV0cvWmpxVktCWTE1SEFiCmY5Y0Zld0hheUVnR01waDFhYjA2a2lkVmx2d3Fhb0NyZU1MWGh4RWxSVDUzOFk5b25wM1JMR3FBazNoTlB4UUdiQlh2TUlDUHkxenAKUExJblZSYjhMR280bEVFMHN6N0VpSnZEQlh4bEhTSlQwUzFxMkpzQldtTEF3QzhNNUUzR2xYSTNWNFJQcW96NVc5UlFoOWM1eGZvZwpJK3hkTGcvYnFpMWVSTG1vb1J4M2NyZXVBakV4bjdjWXhKY3A2enJTSjFXRy9DNXF5T1d2M0dWOW1KRzBnVnQ1S3RwblpiU0xHdUJJCjNtQi82eENKdFl3UEdNWUhyTjNwZHlOL1VtWEEvNklHNk1QVCttN0dvNmxjR0wyclBIWVYvYUtHbWp4Tkwrc1FpYmFPRHhuS2V6dWUKeEJlRGs4cXpZSW9hZWpKQVZaMjJRdnB5S3h1dFkyUXZEa1VOMEpOK3VwUEwyRmJHTTR4M21hNmk5bFVmK2xrZmJFVDh3cFVNc3c3aApSbHlLR3ByeENwMnNRd2p3UFFkWlJ6QVFYRkhEQTl4aGZiZ1JNSncrTExFTzRVcDhpaHJLY1F2M1VjazZoaVJTa0VXZHk5dWNiWDNBCm9iYUdtM25lT29STGNTcHFnRGIwNXpEckVKSkFRUlkxVkdVMGgxc2ZjbWg5UVc5K3RBN2hWcTUxQU1lbWNBejNsM2xEaG9ock9ZSHUKYlQwOTR2Tmp2Vk1idVpWT2NhdnArSTJvaXh6RkM3U3hEaUdKRXV5SUd1QTRQdGIxSDd1WXdKVk1zUTdoaDdpTnFJdE00RkR1WUxOMQpEQkVmamVidjFoRkNaUU4zMERHZU5SM1hFWFdSZHJ5bytXb0pTUEFqYXNqbHY1eG9mZUFoTVo1TDRqZmg4YXQ0anFpTFRPUW83b2pECnhlNGlLUlZ3a1dhcXQxa1E1NXFPOTRpNlNFdWU0VGpyRUJKN200MHVERDJWOXdMK0lqT3N1dkt4ZFFUL3hIbEVYV1E2WGJoaXg4M04KSXY2d0d2Rjh3RlBXaHg0U1QxREJPb0ovNGwvVVVNaExIRWkvUk43WUxQRjNHejlZUndpRlZseHZIY0UvOFovNitGVVhucWFGZFFpSgpLYXVwRDRCaitFd1g2Z0ZyYU1raTZ4RCtTTUtJZXJ0UnRPTnUxbHZIRUhIc1MwMS9BRkNkQjZ3aitDVkpJK29pamZrM1BheERTT3dFCk42S3VRU1AyWm04YXNSZjdzaGVOYUtEeDlEYUZkR2FjZFFnL0pLK29BYnJ5T0syc1EwaXN1Qy9xR3RTbkh2V29SMTNxc2VlMnYrL0wKSHRhSEdtcmZjZ1JiclVPNGw4eWloZ3JjeUYrb2JoMURZc05yVWU5Qk5XcFFnMXJVb0RvMXFFNU5hbTM3cHpyVXBSNFZyUThwb243SAowOVlSM0V0cVVRUHN4Zjl4V2FKbTZjVS9XN21UcXNYS3VoSlZBYWhGRGpYSnBRYmxxRUU1cWxPZWFuRytrTXpjQ3BxenpEcUVhMGt1CmFvRFcvRXRyTzR2RXlyTmNheDNCdGFRWE5VQlhIcU8xZFFnUmNhU0FZL2pTT29SYitzRWZSbklvdDdEQ09vYUlPSkZMMzdnMVc4d08KSjBPYitUZjc4eEFicklPSWlBT0hjNmwxQkxjMDlWRmNJKzdtU2wyVEtoSjVQOU9DbGRZaDNOR0l1cmdGWEVOYkJsckhFSkVzN2NtOQoxaEZjMG9nNmxjNzhuYzdXSVVRa0MvbTBaNUoxQ0ZjMG9rN2xNNDZsTTJPc1k0aEl4c3JUTno1UDZsWlJsMlFzeDNFU2VkWXhSQ1JECm5iakFPb0lybXZvb1hRNDl1RmNybW90RTBrSmFzdFk2aEFzYVVaZXVrRUVjekZrYVdZdEUwRDdjYVIzQkRZMm8wNVBER2R6RmtkWXgKUk1TVHpSek1ET3NRMmRPSU9qMkZET01vT2pQS09vaUllRkNSSjZ3anVLQ2k5bUlzSjlDVmtkWXhSQ1J0SjNHMmRZVHNhZW9qRSsyNApoVjZVdDQ0aEltbVlSNnVvTDhHbkVYVW1KdEtiNWp3ZTlmL3pSUktoTWJkYVI4aVdSdFRaYU1BTlhFc2Q2eGdpVXFvTnRHR09kWWhzCnFLaXpWWWtMdUYzUHN4WUp0YmVqdmFTMWl0cUZIRTdrUms2UHp3MnJJckZ6R2g5WVI4aWNpdHFkdHR6RWhWUzJqaUVpS2N5a0xadXMKUTJSS1h5YTZNNWtyMll1Ym9qMFhKaEpUQjNLamRZVE1hVVR0WGk0bmNEWGR0UUNCU0tpc3BTVUxyVU5rUmtYdGx3TzRpcXVvYXgxRApSSFo0ZzR1c0kyUkdSZTJuU3B6RjFaeW9MeGxGUXFJTG4xcEh5SVNLMm44dHVKd3JxRzhkUTBTWXdpSGtXNGZ3VGtVZGpFcDBwdy9ICmEyd3RZdXlHS0Q2bVNVVWRwSDI1a0Q3c2J4MURKTUZXMDRJbDFpRzhVbEVITFpjT1hNS0ZWTE1PSXBKUUwzQ1ZkUVN2Vk5RMnFuRWUKbDlGWjE3R0xCSzZBRGt5d0R1R05pdHJTUHB4SFR6cGF4eEJKbUR5T3BNQTZoQmNxYW51dHVJQUxPZEE2aGtpQzlPRjU2d2hlcUtqRApJWWRqK0EwOTJOczZpRWdpTEtjRnk2MURwRTlGSFNhNWRLQW5QZGpIT29oSTdEM0o5ZFlSMHFlaURoL1Z0WWovdG5JNDMxbUhTSmVLCk9xeHlPWVp6T0ljRHJJT0l4TlE0T2hPUkFsUlJoMTB6enFRbkhYUlBvNGh6Ri9PNmRZVDBxS2lqb1JGbmN4YkhVY2s2aUVpTUxLRWwKcTZ4RHBFTkZIU1ZWNmNDWm5NdSsxa0Vrd3VZd2toTnBaaDBqSkI3bU51c0k2VkJSUjA4T2gzQWFaM0NrN21zVUQvTDVqUGQ1ajJuQQphYnhuSFNja3R0Q09hZFloeXFhaWpxNjZuRUJYVHFhSmRSQUp1ZG1NWkNRaldGbnM5ejZoaTNXc2tQaVlydFlSeXFhaWpyNW1kS1VyCjNhaHBIVVJDWmkzakdjN1FsS3Q0SHNsNGZVRzlUUS9ldG81UUZoVjFYRlRrYUU2Z0MwZnBDOGZFVzhjNFJqR0tyOWxheXF2ZTVTenIKb0NFeG4xYXNzdzVST2hWMTNGU2hQUjNwU21jVmR1TGtNNUdSak9Rek5xWHg2cFpNcHJ4MTVKQzRqM3VzSTVST1JSMVgxZWhFSnpwegpCRldzbzRqUDF2QUY0eGpEZURaNmV0L0xYR29kUFNRMjBaYVoxaUZLbzZLT3UvSzBveE1kNlVJOTZ5amkyRksrWWl6aitKTE5HYjIvCkNUUDBjOWMyUXpuYk9rSnBWTlJKa1VOcmp1Rm9qcUsxTHV1THRId21NWjRKZk9GZ0RQZ0lOMWtmVG1pY0VlWkxGbFhVeVZPTlEyaFAKUjQ2bGdYVVU4V0F4ZWVReGxzOVo3MnliOVpoRkRlc0RDNGxadEVscmJ0K0VpanJKOXFQOXRyL3FXa2VSRWl6bUcvTElJNCtGdm16LwpIdTYxUHNUUStETVBXRWNvaVlwYW9LaXlENk05aDJpVUhRcnorVzViUVMveWVVL1YrRkgvbjIrem50Yk10UTZSbW9wYWRsYWJOclNuCk5XMDRUTmVMQkdvTE04bGpDbE9ad004Qjd2ZEdIclUrOU5ENEQ3K3hqcENhaWxwS1VvR1dITVJCdEtRTisrdUtXMTlzWmdiVG1NcFUKSmpPejFOdFQvRk9SYVhwRTB3NG44b2wxaEZSVTFKS09palNuRmExcFRRc09wS3AxbkVoYnpVeG1NSVhwZk05czhxM2pBTDE1eFRwQwphRXpsRUxaWWg5aWRpbHE4cTAwejJ0Q2FaalNqbFdxN1RKdFp3R3ltTW9YWnpHWk82RllWeWVVYjJsbUhDSTAvaEhFcVNFVXQyYXBOCnMySi9OYUdjZGFBUVdNSHNZbi9OTlpyVVNOK1pETFdPRUJxcmFjbGk2eEM3VWxHTFd4VnBITzZiY1gxU3lKTXNZQ0h6bU0rQ1VFeG8KZVBNcHgxbEhDSTJYdWR3NndxNVUxT0plRWsrcWZDcFlSOGhLSno2empoQWFoUndYdGs5RE54T0xDSXdOOHczVUFjdmhzYkJONEttbwpSUVRnVHhSWVJ3aU5RK2xqSFdGbm12b1E5NUo0VWtWOTZnUGdWUzYyamhBYS82TUZ5NnhEL0VvamFoRXBjbmQ0SDBvVXVEcmNaeDJoCk9CVzFpQlQ1aVg3V0VVTGtHbzZ3anZBclRYMkllMGs4cWVJdzlRSDFtVVYxNnhDaDhRVWR3M0l1YTBRdDRrSThWdlQrSll4MzVaazUKaHQ3V0ViYlRpRnJjUytKSnRUVW1qNjJxem8vc2FSMGlOSmJTa3BYV0lVQWphaEVwYmcwUFdVY0lrUWI4eFRwQ0VZMm94YjBrbmxSeApHVkZEUmFiVDFEcEVhT1J6R0pPdFEyaEVMU0k3Mjh6ZnJDT0VTSG42aHVIN0I0Mm94YjBrbmxUeEdWRkRPU2JTeGpwRWlGekFXOVlSClZOVGlYaEpQcWpnVk5aekwyOVlSUW1RQnJWaHJHMEZUSHlLeXF5RjhiaDBoUkJyeEorc0lHbEdMZTBrOHFlSTFvb2JPakxHT0VDS2IKYWNzUGxnRTBvaGFSM1gzR2g5WVJRcVFpVDlnRzBJaGEzRXZpU1JXM0VUVWN6TGNheUJWekZzUHNkcTcvSTBRa2xVbjh4enBDcUR4SwpaYnVkcTZoRkpMVTcyV3dkSVVTYWNhdmR6bFhVSXBMYUhGNndqaEFxZjJJL3ExMXJqbHJjUytKSkZiODVhb0M5bU1rZTFpRkNaRERuCjJleFlJMm9SS2NsaUhyT09FQ285T01WbXh4cFJpM3RKUEtuaU9hS0dtc3lpcm5XSUVKbEpXNHNGeXpTaUZwR1NyZEpqVDNkeUlOZGIKN0ZZamFuRXZpU2RWWEVmVVVKa2YyTmM2Uklpc29TV0xndDZwUnRRaVVwcU40VnFQMjF4MWk1OHhOS0lXOTVKNFVzVjNSQTNsbUV3cgo2eEFoVWtnWFJnZTdTNDJvUmFSMFc4T3lJRlZJNVBCazBQOVpWbEdMU0ZrR005NDZRcWdjeERYQjdsQlRIK0plRWsrcUFzcFpSL0RWCmNYeHFIU0ZVVnRDQ1g0TGJuVWJVSWxLMjBZeXdqaEFxdGZsN2tMdlRpRnJjUytKSkZmY1JOYlRucXpBczh4b2FCWFJnUWxBNzA0aGEKUk5LUngwRHJDS0dTUzkvZytsTkZMU0xwdVlzdDFoRkNwVDJYQmJVckZiV0lwR2NtTDFsSENKa0hxQlhNamxUVUlwS3VlMWx2SFNGVQo5dVN2d2V4SVJTMGk2VnBzdmNocjZQeWVka0hzUmxkOWlIdEpQS25pZjlWSGtWck1vbzUxaUZBWnk3SCtuL0VhVVl0SStsYnlzSFdFCmtPbkViL3pmaVViVTRsNFNUNnFraktpaENqL1F5RHBFcUN5aEJhdjkzWVZHMUNMaXhZWmc3OG1MZ0liODJlOWRhRVF0N2lYeHBFck8KaUJyS001bVcxaUZDWlRQdG1PN25EalNpRmhGdjhyblhPa0xJVlBUN2FoaU5xTVc5Sko1VVNScFJRdzVmMGQ0NlJNaDBaNGgvRzFkUgppM3RKUEttU1ZkVFFqWStzSTRUTVBGcjVkenVRcGo1RXhMdi84ckYxaEpCcHpHMytiVndqYW5FdmlTZFYwa2JVY0FRVDlOalRuV3lnCkRYUDgyYlJHMUNLU2lhLzhuSk9OcENyODI2OU5hMFF0N2lYeHBFcmVpQnFhTXlYR2E2OW41blRlOTJPekdsR0xTR1orNEJYckNLSHoKR0pYODJLeUtXa1F5ZFk4ZWU3cUxBN2pKajgycXFFVWtVd3Q1eWpwQzZQeUZ4dTQzcWpscWNTK0pKMVZoUWdjOXRabEZiZXNRSVRPQQpDMTF2TXBrbmw0aTRzWUovV1VjSW5WNTBjYjFKamFqRnZTU2VWRWtkVWNNZS9FaEQ2eEFoTTRWRDNTNEVuTlNUUzBUY1dNZi9XVWNJCm5UYjh6dTBHTmFJVzk1SjRVaVYzUkEwVm1Nb0IxaUZDWmpVdFdleHVjOGs5dVVURWpTM2NZeDBoZEdxNC9UbERJMnB4TDRrblZaSkgKMUpCREhvZGFod2laUWpvdzN0WEdrbnh5aVlnYmhkeHBIU0YwY3VqcjdyRUNLbW9SeWQ0SGpMS09FRHFIY2FXclRXbnFROXhMNGttVgo3S2tQZ0NNWnI4ZWU3dUovdEdDWml3MGwvZVFTRVRlK1pLaDFoTkNwdzEvZGJFZ2phbkV2aVNlVlJ0VFFndS8xMk5OZEZIQVVYMmUvCkdaMWNJdUxHREY2empoQTZ1VHptWWtKSUkycHhMNGtubFViVUFFMlk0Yy96bUNPdE42OW11d21kWENMaXlsdzk5alNGaDZtWjdTWlUKMUNMaXp2MnN0bzRRT2cyNE85dE5xS2hGeEoxbGV1eHBDamZTTnJzTmFJNWEzRXZpU2FVNTZ1MnE4U01OckVPRXpzZDB6ZWJ0T3JsRQp4S1cxM0c4ZElZUk81THhzM3E0UnRiaVh4Sk5LSStwZlZXUXErMXVIQ0ozNXRHSmRwbS9XeVNVaWJtMTJkVDllck96TEhabS9XU05xCmNTK0pKNVZHMU1YbGtzY2gxaUZDWnpOdCtTR3p0K3JrRW5GQmp5TXFyb0MvV0VjSW9ZcVpYeEdqRWJXSStLRzI4ZjRMV0dYOUViaWoKb2hZUkNibi9COEVEK0RkNElkSHFBQUFBQUVsRlRrU3VRbUNDIiAvPgo8L3N2Zz4K" id="back-cover-1-pagedown-attachment" rel="attachment" />
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array 
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.querySelector(href);
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = window.location.hash.replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	global.PagedPolyfill = factory();
}(typeof self !== 'undefined' ? self : this, function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n.default || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function"){
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if(element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		let after = node;

		if (after.nextSibling) {
			if (limiter && node === limiter) {
				return;
			}
			after = after.nextSibling;
		} else {
			while (after) {
				after = after.parentNode;
				if (limiter && after === limiter) {
					after = undefined;
					break;
				}
				if (after && after.nextSibling) {
					after = after.nextSibling;
					break;
				}
			}
		}

		return after;
	}

	function nodeBefore(node, limiter) {
		let before = node;
		if (before.previousSibling) {
			if (limiter && node === limiter) {
				return;
			}
			before = before.previousSibling;
		} else {
			while (before) {
				before = before.parentNode;
				if (limiter && before === limiter) {
					before = undefined;
					break;
				}
				if (before && before.previousSibling) {
					before = before.previousSibling;
					break;
				}
			}
		}

		return before;
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after);
		}

		return after;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				(node.dataset.page || node.dataset.afterPage)
			 ) {
			return true;
		}

		return false;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

	  /**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
	  triggerSync(){
	    var args = arguments;
	    var context = this.context;
	    var results = [];

	    this.hooks.forEach(function(task) {
	      var executing = task.apply(context, args);

	      results.push(executing);
	    });


	    return results;
	  }

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, maxChars) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.maxChars = maxChars || MAX_CHARS_PER_BREAK;
		}

		async renderTo(wrapper, source, breakToken, bounds=this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			while (!done && !newBreakToken) {
				next = walker.next();
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset=0) {
			return {
				node,
				offset
			};
		}

		shouldBreak(node) {
			let previousSibling = node.previousSibling;
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node);
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow=true, rebuild=true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function() {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function(e) {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let { width, height } = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if(window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						renderedNode = findElement(prevValidNode(temp), rendered);
						return;
					}

					node = findElement(renderedNode, source);
					offset = 0;
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					node = child(parent, index);
					offset = 0;
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return {
				node,
				offset
			};

		}

		findBreakToken(rendered, source, bounds=this.bounds, extract=true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);

				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});


				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds=this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let { width } = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds=this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end =  Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.floor(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						if (isElement(node) ) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.setStartBefore(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

					}

					if (!range && isText(node) &&
							node.textContent.trim().length &&
							window.getComputedStyle(node.parentNode)["break-inside"] !== "avoid") {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if(left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right < end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds=this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if(!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer);

			return extracted;
		}

		hyphenateAtBreak(startContainer) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length-1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (/^\w|\u00AD$/.test(prevLetter)) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += "\u2011";
				}
			}
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum+1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute('id', id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if(e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function() {
				if(this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element &&this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver( entries => {

				if (!this.listening) {
					return;
				}

				for (let entry of entries) {
					const cr = entry.contentRect;

					if (cr.height > prevHeight) {
						this.checkOverflowAfterResize(contents);
						prevHeight = wrapper.getBoundingClientRect().height;
					} else if (cr.height < prevHeight ) { // TODO: calc line height && (prevHeight - cr.height) >= 22
						this.checkUnderflowAfterResize(contents);
						prevHeight = cr.height;
					}
				}
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			// let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);
			this.removeEmpty(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);
			this.removeEmpty(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				{ acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		removeEmpty(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_TEXT,
				{ acceptNode: function(node) {
					// Only remove more than a single space
					if (node.textContent.length > 1 && !node.textContent.trim()) {

						// Don't touch whitespace if text is preformated
						let parent = node.parentNode;
						let pre = isElement(parent) && parent.closest("pre");
						if (pre) {
							return NodeFilter.FILTER_REJECT;
						}

						return NodeFilter.FILTER_ACCEPT;
					} else {
						return NodeFilter.FILTER_REJECT;
					}
				} },
				false
			);

			let node;
			let current;
			node = treeWalker.nextNode();
			while(node) {
				current = node;
				node = treeWalker.nextNode();
				// if (!current.nextSibling || (current.nextSibling && current.nextSibling.nodeType === 1)) {
				current.parentNode.removeChild(current);
				// }
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		// isWrapper(element) {
		//   return wrappersRegex.test(element.nodeName);
		// }

		isText(node) {
			return node.tagName === "TAG";
		}

		isElement(node) {
			return node.nodeType === 1;
		}

		hasChildren(node) {
			return node.childNodes && node.childNodes.length;
		}


		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo) {
			// this.preview = preview;

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this._total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", content);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);

			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt);

			let done = false;
			let result;

			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && (true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}
		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/

		get total() {
			return this._total;
		}

		set total(num) {
			this.pagesArea.style.setProperty("--pagedjs-page-count", num);
			this._total = num;
		}

		loadFonts() {
			let fontPromises = [];
			document.fonts.forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//            item        item        item        item
	//          /------\    /------\    /------\    /------\
	//          | data |    | data |    | data |    | data |
	//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
	//          | next-+--->| next-+--->| next-+--->| next-+--> null
	//          \------/    \------/    \------/    \------/
	//             ^                                    ^
	//             |                list                |
	//             |              /------\              |
	//             \--------------+-head |              |
	//                            | tail-+--------------/
	//                            \------/
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var list = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var CssSyntaxError = function(message, source, offset, line, column) {
	    var error = createCustomError('CssSyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var error = CssSyntaxError;

	// token types (note: value shouldn't intersect with used char codes)
	var WHITESPACE = 1;
	var IDENTIFIER = 2;
	var NUMBER = 3;
	var STRING = 4;
	var COMMENT = 5;
	var PUNCTUATOR = 6;
	var CDO = 7;
	var CDC = 8;
	var ATKEYWORD = 14;
	var FUNCTION = 15;
	var URL$1 = 16;
	var RAW = 17;

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var TYPE = {
	    WhiteSpace:   WHITESPACE,
	    Identifier:   IDENTIFIER,
	    Number:           NUMBER,
	    String:           STRING,
	    Comment:         COMMENT,
	    Punctuator:   PUNCTUATOR,
	    CDO:                 CDO,
	    CDC:                 CDC,
	    AtKeyword:     ATKEYWORD,
	    Function:       FUNCTION,
	    Url:                 URL$1,
	    Raw:                 RAW,

	    ExclamationMark:      33,  // !
	    QuotationMark:        34,  // "
	    NumberSign:           35,  // #
	    DollarSign:           36,  // $
	    PercentSign:          37,  // %
	    Ampersand:            38,  // &
	    Apostrophe:           39,  // '
	    LeftParenthesis:      40,  // (
	    RightParenthesis:     41,  // )
	    Asterisk:             42,  // *
	    PlusSign:             43,  // +
	    Comma:                44,  // ,
	    HyphenMinus:          45,  // -
	    FullStop:             46,  // .
	    Solidus:              47,  // /
	    Colon:                58,  // :
	    Semicolon:            59,  // ;
	    LessThanSign:         60,  // <
	    EqualsSign:           61,  // =
	    GreaterThanSign:      62,  // >
	    QuestionMark:         63,  // ?
	    CommercialAt:         64,  // @
	    LeftSquareBracket:    91,  // [
	    Backslash:            92,  // \
	    RightSquareBracket:   93,  // ]
	    CircumflexAccent:     94,  // ^
	    LowLine:              95,  // _
	    GraveAccent:          96,  // `
	    LeftCurlyBracket:    123,  // {
	    VerticalLine:        124,  // |
	    RightCurlyBracket:   125,  // }
	    Tilde:               126   // ~
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
	var SYMBOL_TYPE = new SafeUint32Array(0x80);
	var PUNCTUATION = new SafeUint32Array(0x80);
	var STOP_URL_RAW = new SafeUint32Array(0x80);

	for (var i = 0; i < SYMBOL_TYPE.length; i++) {
	    SYMBOL_TYPE[i] = IDENTIFIER;
	}

	// fill categories
	[
	    TYPE.ExclamationMark,    // !
	    TYPE.QuotationMark,      // "
	    TYPE.NumberSign,         // #
	    TYPE.DollarSign,         // $
	    TYPE.PercentSign,        // %
	    TYPE.Ampersand,          // &
	    TYPE.Apostrophe,         // '
	    TYPE.LeftParenthesis,    // (
	    TYPE.RightParenthesis,   // )
	    TYPE.Asterisk,           // *
	    TYPE.PlusSign,           // +
	    TYPE.Comma,              // ,
	    TYPE.HyphenMinus,        // -
	    TYPE.FullStop,           // .
	    TYPE.Solidus,            // /
	    TYPE.Colon,              // :
	    TYPE.Semicolon,          // ;
	    TYPE.LessThanSign,       // <
	    TYPE.EqualsSign,         // =
	    TYPE.GreaterThanSign,    // >
	    TYPE.QuestionMark,       // ?
	    TYPE.CommercialAt,       // @
	    TYPE.LeftSquareBracket,  // [
	    // TYPE.Backslash,          // \
	    TYPE.RightSquareBracket, // ]
	    TYPE.CircumflexAccent,   // ^
	    // TYPE.LowLine,            // _
	    TYPE.GraveAccent,        // `
	    TYPE.LeftCurlyBracket,   // {
	    TYPE.VerticalLine,       // |
	    TYPE.RightCurlyBracket,  // }
	    TYPE.Tilde               // ~
	].forEach(function(key) {
	    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
	    PUNCTUATION[Number(key)] = PUNCTUATOR;
	});

	for (var i = 48; i <= 57; i++) {
	    SYMBOL_TYPE[i] = NUMBER;
	}

	SYMBOL_TYPE[SPACE] = WHITESPACE;
	SYMBOL_TYPE[TAB] = WHITESPACE;
	SYMBOL_TYPE[N] = WHITESPACE;
	SYMBOL_TYPE[R] = WHITESPACE;
	SYMBOL_TYPE[F] = WHITESPACE;

	SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
	SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

	STOP_URL_RAW[SPACE] = 1;
	STOP_URL_RAW[TAB] = 1;
	STOP_URL_RAW[N] = 1;
	STOP_URL_RAW[R] = 1;
	STOP_URL_RAW[F] = 1;
	STOP_URL_RAW[TYPE.Apostrophe] = 1;
	STOP_URL_RAW[TYPE.QuotationMark] = 1;
	STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
	STOP_URL_RAW[TYPE.RightParenthesis] = 1;

	// whitespace is punctuation ...
	PUNCTUATION[SPACE] = PUNCTUATOR;
	PUNCTUATION[TAB] = PUNCTUATOR;
	PUNCTUATION[N] = PUNCTUATOR;
	PUNCTUATION[R] = PUNCTUATOR;
	PUNCTUATION[F] = PUNCTUATOR;
	// ... hyper minus is not
	PUNCTUATION[TYPE.HyphenMinus] = 0;

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME,

	    SYMBOL_TYPE: SYMBOL_TYPE,
	    PUNCTUATION: PUNCTUATION,
	    STOP_URL_RAW: STOP_URL_RAW
	};

	var PUNCTUATION$1 = _const.PUNCTUATION;
	var STOP_URL_RAW$1 = _const.STOP_URL_RAW;
	var TYPE$1 = _const.TYPE;
	var FULLSTOP = TYPE$1.FullStop;
	var PLUSSIGN = TYPE$1.PlusSign;
	var HYPHENMINUS = TYPE$1.HyphenMinus;
	var PUNCTUATOR$1 = TYPE$1.Punctuator;
	var TAB$1 = 9;
	var N$1 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var BACK_SLASH = 92;
	var E = 101; // 'e'.charCodeAt(0)

	function firstCharOffset(source) {
	    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
	        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
	        return 1;
	    }

	    return 0;
	}

	function isHex(code) {
	    return (code >= 48 && code <= 57) || // 0 .. 9
	           (code >= 65 && code <= 70) || // A .. F
	           (code >= 97 && code <= 102);  // a .. f
	}

	function isNumber(code) {
	    return code >= 48 && code <= 57;
	}

	function isWhiteSpace(code) {
	    return code === SPACE$1 || code === TAB$1 || isNewline(code);
	}

	function isNewline(code) {
	    return code === R$1 || code === N$1 || code === F$1;
	}

	function getNewlineLength(source, offset, code) {
	    if (isNewline(code)) {
	        if (code === R$1 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$1) {
	            return 2;
	        }

	        return 1;
	    }

	    return 0;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (code >= 65 && code <= 90) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var refCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (testCode >= 65 && testCode <= 90) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== refCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
	        offset--;
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findCommentEnd(source, offset) {
	    var commentEnd = source.indexOf('*/', offset);

	    if (commentEnd === -1) {
	        return source.length;
	    }

	    return commentEnd + 2;
	}

	function findStringEnd(source, offset, quote) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // TODO: bad string
	        if (code === BACK_SLASH) {
	            offset++;
	        } else if (code === quote) {
	            offset++;
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findNumberEnd(source, offset, allowFraction) {
	    var code;

	    offset = findDecimalNumberEnd(source, offset);

	    // fraction: .\d+
	    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
	        code = source.charCodeAt(offset + 1);

	        if (isNumber(code)) {
	            offset = findDecimalNumberEnd(source, offset + 1);
	        }
	    }

	    // exponent: e[+-]\d+
	    if (offset + 1 < source.length) {
	        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
	            code = source.charCodeAt(offset + 1);

	            if (code === PLUSSIGN || code === HYPHENMINUS) {
	                if (offset + 2 < source.length) {
	                    code = source.charCodeAt(offset + 2);
	                }
	            }

	            if (isNumber(code)) {
	                offset = findDecimalNumberEnd(source, offset + 2);
	            }
	        }
	    }

	    return offset;
	}

	// skip escaped unicode sequence that can ends with space
	// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
	function findEscapeEnd(source, offset) {
	    for (var i = 0; i < 7 && offset + i < source.length; i++) {
	        var code = source.charCodeAt(offset + i);

	        if (i !== 6 && isHex(code)) {
	            continue;
	        }

	        if (i > 0) {
	            offset += i - 1 + getNewlineLength(source, offset + i, code);
	            if (code === SPACE$1 || code === TAB$1) {
	                offset++;
	            }
	        }

	        break;
	    }

	    return offset;
	}

	function findIdentifierEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$1) {
	            break;
	        }
	    }

	    return offset;
	}

	function findUrlRawEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {
	            break;
	        }
	    }

	    return offset;
	}

	var utils = {
	    firstCharOffset: firstCharOffset,

	    isHex: isHex,
	    isNumber: isNumber,
	    isWhiteSpace: isWhiteSpace,
	    isNewline: isNewline,
	    getNewlineLength: getNewlineLength,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd,
	    findCommentEnd: findCommentEnd,
	    findStringEnd: findStringEnd,
	    findDecimalNumberEnd: findDecimalNumberEnd,
	    findNumberEnd: findNumberEnd,
	    findEscapeEnd: findEscapeEnd,
	    findIdentifierEnd: findIdentifierEnd,
	    findUrlRawEnd: findUrlRawEnd
	};

	var TYPE$2 = _const.TYPE;
	var NAME$1 = _const.NAME;
	var SYMBOL_TYPE$1 = _const.SYMBOL_TYPE;


	var firstCharOffset$1 = utils.firstCharOffset;
	var cmpStr$1 = utils.cmpStr;
	var isNumber$1 = utils.isNumber;
	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var findCommentEnd$1 = utils.findCommentEnd;
	var findStringEnd$1 = utils.findStringEnd;
	var findNumberEnd$1 = utils.findNumberEnd;
	var findIdentifierEnd$1 = utils.findIdentifierEnd;
	var findUrlRawEnd$1 = utils.findUrlRawEnd;

	var NULL = 0;
	var WHITESPACE$1 = TYPE$2.WhiteSpace;
	var IDENTIFIER$1 = TYPE$2.Identifier;
	var NUMBER$1 = TYPE$2.Number;
	var STRING$1 = TYPE$2.String;
	var COMMENT$1 = TYPE$2.Comment;
	var PUNCTUATOR$2 = TYPE$2.Punctuator;
	var CDO$1 = TYPE$2.CDO;
	var CDC$1 = TYPE$2.CDC;
	var ATKEYWORD$1 = TYPE$2.AtKeyword;
	var FUNCTION$1 = TYPE$2.Function;
	var URL$2 = TYPE$2.Url;
	var RAW$1 = TYPE$2.Raw;

	var N$2 = 10;
	var F$2 = 12;
	var R$2 = 13;
	var STAR = TYPE$2.Asterisk;
	var SLASH = TYPE$2.Solidus;
	var FULLSTOP$1 = TYPE$2.FullStop;
	var PLUSSIGN$1 = TYPE$2.PlusSign;
	var HYPHENMINUS$1 = TYPE$2.HyphenMinus;
	var GREATERTHANSIGN = TYPE$2.GreaterThanSign;
	var LESSTHANSIGN = TYPE$2.LessThanSign;
	var EXCLAMATIONMARK = TYPE$2.ExclamationMark;
	var COMMERCIALAT = TYPE$2.CommercialAt;
	var QUOTATIONMARK = TYPE$2.QuotationMark;
	var APOSTROPHE = TYPE$2.Apostrophe;
	var LEFTPARENTHESIS = TYPE$2.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE$2.RightParenthesis;
	var LEFTCURLYBRACKET = TYPE$2.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE$2.RightCurlyBracket;
	var LEFTSQUAREBRACKET = TYPE$2.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE$2.RightSquareBracket;

	var MIN_BUFFER_SIZE = 16 * 1024;
	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;
	var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	function computeLinesAndColumns(tokenizer, source) {
	    var sourceLength = source.length;
	    var start = firstCharOffset$1(source);
	    var lines = tokenizer.lines;
	    var line = tokenizer.startLine;
	    var columns = tokenizer.columns;
	    var column = tokenizer.startColumn;

	    if (lines === null || lines.length < sourceLength + 1) {
	        lines = new SafeUint32Array$1(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
	        columns = new SafeUint32Array$1(lines.length);
	    }

	    for (var i = start; i < sourceLength; i++) {
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$2 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$2) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    tokenizer.linesAnsColumnsComputed = true;
	    tokenizer.lines = lines;
	    tokenizer.columns = columns;
	}

	function tokenLayout(tokenizer, source, startPos) {
	    var sourceLength = source.length;
	    var offsetAndType = tokenizer.offsetAndType;
	    var balance = tokenizer.balance;
	    var tokenCount = 0;
	    var prevType = 0;
	    var offset = startPos;
	    var anchor = 0;
	    var balanceCloseCode = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
	        offsetAndType = new SafeUint32Array$1(sourceLength + 1024);
	        balance = new SafeUint32Array$1(sourceLength + 1024);
	    }

	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = code < 0x80 ? SYMBOL_TYPE$1[code] : IDENTIFIER$1;

	        balance[tokenCount] = sourceLength;

	        switch (type) {
	            case WHITESPACE$1:
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            case PUNCTUATOR$2:
	                switch (code) {
	                    case balanceCloseCode:
	                        balancePrev = balanceStart & OFFSET_MASK;
	                        balanceStart = balance[balancePrev];
	                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
	                        balance[tokenCount] = balancePrev;
	                        balance[balancePrev++] = tokenCount;
	                        for (; balancePrev < tokenCount; balancePrev++) {
	                            if (balance[balancePrev] === sourceLength) {
	                                balance[balancePrev] = tokenCount;
	                            }
	                        }
	                        break;

	                    case LEFTSQUAREBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTSQUAREBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTCURLYBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTCURLYBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTPARENTHESIS:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTPARENTHESIS;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;
	                }

	                // /*
	                if (code === STAR && prevType === SLASH) {
	                    type = COMMENT$1;
	                    offset = findCommentEnd$1(source, offset + 1);
	                    tokenCount--; // rewrite prev token
	                    break;
	                }

	                // edge case for -.123 and +.123
	                if (code === FULLSTOP$1 && (prevType === PLUSSIGN$1 || prevType === HYPHENMINUS$1)) {
	                    if (offset + 1 < sourceLength && isNumber$1(source.charCodeAt(offset + 1))) {
	                        type = NUMBER$1;
	                        offset = findNumberEnd$1(source, offset + 2, false);
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // <!--
	                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
	                    if (offset + 2 < sourceLength &&
	                        source.charCodeAt(offset + 1) === HYPHENMINUS$1 &&
	                        source.charCodeAt(offset + 2) === HYPHENMINUS$1) {
	                        type = CDO$1;
	                        offset = offset + 3;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // -->
	                if (code === HYPHENMINUS$1 && prevType === HYPHENMINUS$1) {
	                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
	                        type = CDC$1;
	                        offset = offset + 2;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // ident(
	                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER$1) {
	                    offset = offset + 1;
	                    tokenCount--; // rewrite prev token
	                    balance[tokenCount] = balance[tokenCount + 1];
	                    balanceStart--;

	                    // 4 char length identifier and equal to `url(` (case insensitive)
	                    if (offset - anchor === 4 && cmpStr$1(source, anchor, offset, 'url(')) {
	                        // special case for url() because it can contain any symbols sequence with few exceptions
	                        anchor = findWhiteSpaceEnd$1(source, offset);
	                        code = source.charCodeAt(anchor);
	                        if (code !== LEFTPARENTHESIS &&
	                            code !== RIGHTPARENTHESIS &&
	                            code !== QUOTATIONMARK &&
	                            code !== APOSTROPHE) {
	                            // url(
	                            offsetAndType[tokenCount++] = (URL$2 << TYPE_SHIFT) | offset;
	                            balance[tokenCount] = sourceLength;

	                            // ws*
	                            if (anchor !== offset) {
	                                offsetAndType[tokenCount++] = (WHITESPACE$1 << TYPE_SHIFT) | anchor;
	                                balance[tokenCount] = sourceLength;
	                            }

	                            // raw
	                            type = RAW$1;
	                            offset = findUrlRawEnd$1(source, anchor);
	                        } else {
	                            type = URL$2;
	                        }
	                    } else {
	                        type = FUNCTION$1;
	                    }
	                    break;
	                }

	                type = code;
	                offset = offset + 1;
	                break;

	            case NUMBER$1:
	                offset = findNumberEnd$1(source, offset + 1, prevType !== FULLSTOP$1);

	                // merge number with a preceding dot, dash or plus
	                if (prevType === FULLSTOP$1 ||
	                    prevType === HYPHENMINUS$1 ||
	                    prevType === PLUSSIGN$1) {
	                    tokenCount--; // rewrite prev token
	                }

	                break;

	            case STRING$1:
	                offset = findStringEnd$1(source, offset + 1, code);
	                break;

	            default:
	                anchor = offset;
	                offset = findIdentifierEnd$1(source, offset);

	                // merge identifier with a preceding dash
	                if (prevType === HYPHENMINUS$1) {
	                    // rewrite prev token
	                    tokenCount--;
	                    // restore prev prev token type
	                    // for case @-prefix-ident
	                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
	                }

	                if (prevType === COMMERCIALAT) {
	                    // rewrite prev token and change type to <at-keyword-token>
	                    tokenCount--;
	                    type = ATKEYWORD$1;
	                }
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
	        prevType = type;
	    }

	    // finalize arrays
	    offsetAndType[tokenCount] = offset;
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    tokenizer.offsetAndType = offsetAndType;
	    tokenizer.tokenCount = tokenCount;
	    tokenizer.balance = balance;
	}

	//
	// tokenizer
	//

	var Tokenizer = function(source, startOffset, startLine, startColumn) {
	    this.offsetAndType = null;
	    this.balance = null;
	    this.lines = null;
	    this.columns = null;

	    this.setSource(source, startOffset, startLine, startColumn);
	};

	Tokenizer.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        var safeSource = String(source || '');
	        var start = firstCharOffset$1(safeSource);

	        this.source = safeSource;
	        this.firstCharOffset = start;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAnsColumnsComputed = false;

	        this.eof = false;
	        this.currentToken = -1;
	        this.tokenType = 0;
	        this.tokenStart = start;
	        this.tokenEnd = start;

	        tokenLayout(this, safeSource, start);
	        this.next();
	    },

	    lookupType: function(offset) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return NULL;
	    },
	    lookupNonWSType: function(offset) {
	        offset += this.currentToken;

	        for (var type; offset < this.tokenCount; offset++) {
	            type = this.offsetAndType[offset] >> TYPE_SHIFT;

	            if (type !== WHITESPACE$1) {
	                return type;
	            }
	        }

	        return NULL;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenNum) {
	        if (tokenNum === this.currentToken) {
	            return this.tokenStart;
	        }

	        if (tokenNum > 0) {
	            return tokenNum < this.tokenCount
	                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },
	    getOffsetExcludeWS: function() {
	        if (this.currentToken > 0) {
	            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE$1) {
	                return this.currentToken > 1
	                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
	                    : this.firstCharOffset;
	            }
	        }
	        return this.tokenStart;
	    },
	    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
	        var cursor = startToken;
	        var balanceEnd;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // belance end points to offset before start
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            // check token is stop type
	            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
	                case endTokenType1:
	                    break loop;

	                case endTokenType2:
	                    if (includeTokenType2) {
	                        cursor++;
	                    }
	                    break loop;

	                default:
	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }

	        }

	        return cursor - this.currentToken;
	    },
	    isBalanceEdge: function(pos) {
	        var balanceStart = this.balance[this.currentToken];
	        return balanceStart < pos;
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE$1) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE$1 || this.tokenType === COMMENT$1) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.currentToken + tokenCount;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.currentToken + 1;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.eof = true;
	            this.tokenType = NULL;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    eat: function(tokenType) {
	        if (this.tokenType !== tokenType) {
	            var offset = this.tokenStart;
	            var message = NAME$1[tokenType] + ' is expected';

	            // tweak message and offset
	            if (tokenType === IDENTIFIER$1) {
	                // when identifier is expected but there is a function or url
	                if (this.tokenType === FUNCTION$1 || this.tokenType === URL$2) {
	                    offset = this.tokenEnd - 1;
	                    message += ' but function found';
	                }
	            } else {
	                // when test type is part of another token show error for current position + 1
	                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
	                    offset = offset + 1;
	                }
	            }

	            this.error(message, offset);
	        }

	        this.next();
	    },
	    eatNonWS: function(tokenType) {
	        this.skipWS();
	        this.eat(tokenType);
	    },

	    consume: function(tokenType) {
	        var value = this.getTokenValue();

	        this.eat(tokenType);

	        return value;
	    },
	    consumeFunctionName: function() {
	        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

	        this.eat(FUNCTION$1);

	        return name;
	    },
	    consumeNonWS: function(tokenType) {
	        this.skipWS();

	        return this.consume(tokenType);
	    },

	    expectIdentifier: function(name) {
	        if (this.tokenType !== IDENTIFIER$1 || cmpStr$1(this.source, this.tokenStart, this.tokenEnd, name) === false) {
	            this.error('Identifier `' + name + '` is expected');
	        }

	        this.next();
	    },

	    getLocation: function(offset, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },

	    getLocationRange: function(start, end, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    },

	    error: function(message, offset) {
	        var location = typeof offset !== 'undefined' && offset < this.source.length
	            ? this.getLocation(offset)
	            : this.eof
	                ? this.getLocation(findWhiteSpaceStart$1(this.source, this.source.length - 1))
	                : this.getLocation(this.tokenStart);

	        throw new error(
	            message || 'Unexpected input',
	            this.source,
	            location.offset,
	            location.line,
	            location.column
	        );
	    },

	    dump: function() {
	        var offset = 0;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	// extend with error class
	Tokenizer.CssSyntaxError = error;

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    Tokenizer[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(utils).forEach(function(key) {
	    Tokenizer[key] = utils[key];
	});

	// warm up tokenizer to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

	var Tokenizer_1 = Tokenizer;

	var tokenizer = Tokenizer_1;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateSequence(node, forceBraces, decorate) {
	    var result = node.terms.map(function(term) {
	        return generate(term, forceBraces, decorate);
	    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

	    if (node.explicit || forceBraces) {
	        result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
	    }

	    return result;
	}

	function generate(node, forceBraces, decorate) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, forceBraces, decorate) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, forceBraces, decorate) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, forceBraces, decorate);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = 0;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    if (node === null) {
	        mismatchOffset = css.length;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, lexer, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error$1 = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS$2 = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS$2 &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS$2;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS$2 &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS$2) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var findIdentifierEnd$2 = utils.findIdentifierEnd;
	var findNumberEnd$2 = utils.findNumberEnd;
	var findDecimalNumberEnd$1 = utils.findDecimalNumberEnd;
	var isHex$1 = utils.isHex;

	var SYMBOL_TYPE$2 = _const.SYMBOL_TYPE;
	var IDENTIFIER$2 = _const.TYPE.Identifier;
	var PLUSSIGN$2 = _const.TYPE.PlusSign;
	var HYPHENMINUS$3 = _const.TYPE.HyphenMinus;
	var NUMBERSIGN = _const.TYPE.NumberSign;

	var PERCENTAGE = {
	    '%': true
	};

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	function consumeFunction(token, addTokenToMatch, getNextToken) {
	    var length = 1;
	    var cursor;

	    do {
	        cursor = getNextToken(length++);
	    } while (cursor !== null && cursor.node !== token.node);

	    if (cursor === null) {
	        return false;
	    }

	    while (true) {
	        // consume tokens until cursor
	        if (addTokenToMatch() === cursor) {
	            break;
	        }
	    }

	    return true;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(token, addTokenToMatch, getNextToken) {
	    if (token === null) {
	        return false;
	    }

	    var name = token.value.toLowerCase();
	    if (name !== 'calc(' &&
	        name !== '-moz-calc(' &&
	        name !== '-webkit-calc(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function attr$1(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'attr(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function expression(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'expression(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function url(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'url(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function idSelector(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    if (consumeIdentifier(token.value, 1) !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function isNumber$2(str) {
	    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
	}

	function consumeNumber(str, allowFraction) {
	    var code = str.charCodeAt(0);

	    return findNumberEnd$2(str, code === PLUSSIGN$2 || code === HYPHENMINUS$3 ? 1 : 0, allowFraction);
	}

	function consumeIdentifier(str, offset) {
	    var code = str.charCodeAt(offset);

	    if (code < 0x80 && SYMBOL_TYPE$2[code] !== IDENTIFIER$2 && code !== HYPHENMINUS$3) {
	        return offset;
	    }

	    return findIdentifierEnd$2(str, offset + 1);
	}

	function astNode(type) {
	    return function(token, addTokenToMatch) {
	        if (token === null || token.node.type !== type) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function dimension(type) {
	    return function(token, addTokenToMatch, getNextToken) {
	        if (calc(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null) {
	            return false;
	        }

	        var numberEnd = consumeNumber(token.value, true);
	        if (numberEnd === 0) {
	            return false;
	        }

	        if (type) {
	            if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
	                return false;
	            }
	        } else {
	            var unitEnd = consumeIdentifier(token.value, numberEnd);
	            if (unitEnd === numberEnd || unitEnd !== token.value.length) {
	                return false;
	            }
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function zeroUnitlessDimension(type) {
	    var isDimension = dimension(type);

	    return function(token, addTokenToMatch, getNextToken) {
	        if (isDimension(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null || Number(token.value) !== 0) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function number(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, true);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberZeroOne(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 0 || value > 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function integer(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, false);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function positiveInteger(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = findDecimalNumberEnd$1(token.value, 0);
	    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS$3) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function hexColor(token, addTokenToMatch) {
	    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    var length = token.value.length - 1;

	    // valid length is 3, 4, 6 and 8 (+1 for #)
	    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
	        return false;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHex$1(token.value.charCodeAt(i))) {
	            return false;
	        }
	    }

	    addTokenToMatch();
	    return true;
	}

	// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	// https://drafts.csswg.org/css-values-4/#identifier-value
	function customIdent(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    var identEnd = consumeIdentifier(token.value, 0);
	    if (identEnd !== token.value.length) {
	        return false;
	    }

	    var name = token.value.toLowerCase();

	    // § 3.2. Author-defined Identifiers: the <custom-ident> type
	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (name === 'unset' || name === 'initial' || name === 'inherit') {
	        return false;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (name === 'default') {
	        return false;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

	    addTokenToMatch();
	    return true;
	}

	var generic = {
	    'angle': zeroUnitlessDimension(ANGLE),
	    'attr()': attr$1,
	    'custom-ident': customIdent,
	    'decibel': dimension(DECIBEL),
	    'dimension': dimension(),
	    'frequency': dimension(FREQUENCY),
	    'flex': dimension(FLEX),
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'ident': astNode('Identifier'),
	    'integer': integer,
	    'length': zeroUnitlessDimension(LENGTH),
	    'number': number,
	    'number-zero-one': numberZeroOne,
	    'number-one-or-greater': numberOneOrGreater,
	    'percentage': dimension(PERCENTAGE),
	    'positive-integer': positiveInteger,
	    'resolution': dimension(RESOLUTION),
	    'semitones': dimension(SEMITONES),
	    'string': astNode('String'),
	    'time': dimension(TIME),
	    'unicode-range': astNode('UnicodeRange'),
	    'url': url,

	    // old IE stuff
	    'progid': astNode('Raw'),
	    'expression': expression
	};

	var SyntaxParseError = function(message, input, offset) {
	    var error = createCustomError('SyntaxParseError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var error$2 = {
	    SyntaxParseError: SyntaxParseError
	};

	var SyntaxParseError$1 = error$2.SyntaxParseError;

	var TAB$2 = 9;
	var N$3 = 10;
	var F$3 = 12;
	var R$3 = 13;
	var SPACE$2 = 32;

	var Tokenizer$1 = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer$1.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R$3 && code !== N$3 && code !== F$3 && code !== SPACE$2 && code !== TAB$2) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new SyntaxParseError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer$1;

	var TAB$3 = 9;
	var N$4 = 10;
	var F$4 = 12;
	var R$4 = 13;
	var SPACE$3 = 32;
	var EXCLAMATIONMARK$1 = 33;    // !
	var NUMBERSIGN$1 = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE$1 = 39;         // '
	var LEFTPARENTHESIS$1 = 40;    // (
	var RIGHTPARENTHESIS$1 = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$3 = 43;           // +
	var COMMA = 44;              // ,
	var LESSTHANSIGN$1 = 60;       // <
	var GREATERTHANSIGN$1 = 62;    // >
	var QUESTIONMARK = 63;       // ?
	var COMMERCIALAT$1 = 64;       // @
	var LEFTSQUAREBRACKET$1 = 91;  // [
	var RIGHTSQUAREBRACKET$1 = 93; // ]
	var LEFTCURLYBRACKET$1 = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET$1 = 125; // }
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos + 1)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET$1);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$1) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET$1);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$3:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN$1:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET$1) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET$1:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    tokenizer.eat(APOSTROPHE$1);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE$1);
	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	function readType(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1 &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS$1) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET$1);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET$1);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK$1) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET$1:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET$1:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN$1:
	            return tokenizer.nextCharCode() === APOSTROPHE$1
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE$1:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$3:
	        case TAB$3:
	        case N$4:
	        case R$4:
	        case F$4:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT$1:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$3:
	        case QUESTIONMARK:
	        case NUMBERSIGN$1:
	        case EXCLAMATIONMARK$1:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET$1:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(str) {
	    var tokenizer = new tokenizer$1(str);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== str.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node, context);
	};

	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = null;
	        var tokens = [];

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                if (tokens.length > 0) {
	                    switch (curNode.type) {
	                        case 'Dimension':
	                        case 'HexColor':
	                        case 'IdSelector':
	                        case 'Percentage':
	                            if (prev.node === curNode) {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Function':
	                        case 'PseudoClassSelector':
	                        case 'PseudoElementSelector':
	                        case 'Url':
	                            if (chunk === '(') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Atrule':
	                            if (prev.node === curNode && prev.value === '@') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;
	                    }
	                }

	                tokens.push(prev = {
	                    value: chunk,
	                    node: curNode
	                });
	            },
	            result: function() {
	                return tokens;
	            }
	        };
	    }
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$2 = 40;  // (
	var RIGHTPARENTHESIS$2 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$2 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$2
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;

	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 10000;
	var totalIterationCount = 0;

	function mapList(list, fn) {
	    var result = [];

	    while (list) {
	        result.unshift(fn(list));
	        list = list.prev;
	    }

	    return result;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(token.value.length - 1);

	    return (
	        token === ',' ||
	        token === '(' ||
	        token === '[' ||
	        token === '/'
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(0);

	    return (
	        token === ')' ||
	        token === ']' ||
	        token === '/'
	    );
	}

	function internalMatch(tokens, syntax, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenCursor++;
	            token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
	        } while (token !== null && !/\S/.test(token.value));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenCursor + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function pushThenStack(nextSyntax) {
	        thenStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextSyntax) {
	        elseStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenCursor: tokenCursor,
	            token: token,
	            prev: elseStack
	        };
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: syntax.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();

	        if (tokenCursor > longestMatch) {
	            longestMatch = tokenCursor;
	        }

	        return matchStack.token;
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: syntax,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: syntax.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    var iterationCount = 0;
	    var exitReason = EXIT_REASON_MATCH;

	    var matchStack = { type: 'Stub', syntax: null, token: null, tokenCursor: -1, prev: null };
	    var longestMatch = 0;
	    var tokenCursor = -1;
	    var token = null;

	    moveToNextToken();

	    while (true) {
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
	        //         elseStack: mapList(elseStack, x => x.id),
	        //         thenStack: mapList(thenStack, x => x.id),
	        //         token: token && token.value,
	        //         tokenCursor,
	        //         syntax
	        //     }, { depth: null })
	        // );

	        // prevent infinite loop
	        if (++iterationCount === ITERATION_LIMIT) {
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            break;
	        }

	        if (syntax === MATCH$1) {
	            if (thenStack === null) {
	                // turn to MISMATCH when some tokens left unmatched
	                if (token !== null) {
	                    // doesn't mismatch if just one token left and it's an IE hack
	                    if (tokenCursor !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                        syntax = MISMATCH$1;
	                        continue;
	                    }
	                }

	                // break the main loop, return a result - MATCH
	                exitReason = EXIT_REASON_MATCH;
	                break;
	            }

	            // go to next syntax (`then` branch)
	            syntax = thenStack.nextSyntax;

	            // check match is not empty
	            if (syntax === DISALLOW_EMPTY$1) {
	                if (thenStack.matchStack.token === matchStack.token) {
	                    syntax = MISMATCH$1;
	                    continue;
	                } else {
	                    syntax = MATCH$1;
	                }
	            }

	            // close syntax if needed
	            while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
	                closeSyntax();
	            }

	            // pop stack
	            thenStack = thenStack.prev;
	            continue;
	        }

	        if (syntax === MISMATCH$1) {
	            if (elseStack === null) {
	                // break the main loop, return a result - MISMATCH
	                exitReason = EXIT_REASON_MISMATCH;
	                break;
	            }

	            // go to next syntax (`else` branch)
	            syntax = elseStack.nextSyntax;

	            // restore all the rest stack states
	            thenStack = elseStack.thenStack;
	            syntaxStack = elseStack.syntaxStack;
	            matchStack = elseStack.matchStack;
	            tokenCursor = elseStack.tokenCursor;
	            token = elseStack.token;

	            // pop stack
	            elseStack = elseStack.prev;
	            continue;
	        }

	        switch (syntax.type) {
	            case 'MatchGraph':
	                syntax = syntax.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (syntax.else !== MISMATCH$1) {
	                    pushElseStack(syntax.else);
	                }

	                if (syntax.then !== MATCH$1) {
	                    pushThenStack(syntax.then);
	                }

	                syntax = syntax.match;
	                break;

	            case 'MatchOnce':
	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: matchStack,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                if (syntax.index === syntax.terms.length) {
	                    // if no matches during a cycle
	                    if (syntax.matchStack === matchStack) {
	                        // no matches at all or it's required all terms to be matched
	                        if (syntax.mask === 0 || syntax.all) {
	                            syntax = MISMATCH$1;
	                            break;
	                        }

	                        // a partial match is ok
	                        syntax = MATCH$1;
	                        break;
	                    } else {
	                        // start trying to match from the start
	                        syntax.index = 0;
	                        syntax.matchStack = matchStack;
	                    }
	                }

	                for (; syntax.index < syntax.terms.length; syntax.index++) {
	                    if ((syntax.mask & (1 << syntax.index)) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(syntax);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            buffer: syntax
	                        });

	                        // match
	                        syntax = syntax.terms[syntax.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                syntax = syntax.buffer;

	                var newMask = syntax.mask | (1 << (syntax.index - 1));

	                // all terms are matched
	                if (newMask === (1 << syntax.terms.length) - 1) {
	                    syntax = MATCH$1;
	                    continue;
	                }

	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: syntax.matchStack,
	                    index: syntax.index,
	                    mask: newMask
	                };

	                break;

	            case 'Enum':
	                var name = token !== null ? token.value.toLowerCase() : '';

	                // drop \0 and \9 hack from keyword name
	                if (name.indexOf('\\') !== -1) {
	                    name = name.replace(/\\[09].*$/, '');
	                }

	                if (hasOwnProperty$1.call(syntax.map, name)) {
	                    syntax = syntax.map[name];
	                } else {
	                    syntax = MISMATCH$1;
	                }

	                break;

	            case 'Generic':
	                syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH$1 : MISMATCH$1;
	                break;

	            case 'Type':
	            case 'Property':
	                openSyntax();

	                var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

	                if (hasOwnProperty$1.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
	                    syntax = syntaxes[syntaxDict][syntax.name].match;
	                } else {
	                    syntax = undefined;
	                }

	                if (!syntax) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (syntaxStack.syntax.type === 'Type'
	                            ? '<' + syntaxStack.syntax.name + '>'
	                            : '<\'' + syntaxStack.syntax.name + '\'>')
	                    );
	                }

	                break;

	            case 'Keyword':
	                var name = syntax.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (keywordName.toLowerCase() === name) {
	                        addTokenToMatch();

	                        syntax = MATCH$1;
	                        break;
	                    }
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && token.value.toLowerCase() === syntax.name) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === syntax.value) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.value === ',') {
	                    if (isCommaContextStart(matchStack.token)) {
	                        syntax = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        syntax = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            // case 'String':
	            // TODO: strings with length other than 1 char

	            default:
	                throw new Error('Unknown node type: ' + syntax.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    if (exitReason === EXIT_REASON_MATCH) {
	        while (syntaxStack !== null) {
	            closeSyntax();
	        }
	    } else {
	        matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match !== null) {
	        matchResult.match = mapList(matchResult.match, function(item) {
	            if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
	                return { type: item.type, syntax: item.syntax };
	            }

	            return {
	                syntax: item.syntax,
	                token: item.token && item.token.value,
	                node: item.token && item.token.node
	            };
	        }).slice(1);
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var cursor = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph$$1.syntax || null,
	        match: []
	    };
	    var stack = [host];

	    // revert a list
	    var prev = null;
	    var next = null;
	    while (cursor !== null) {
	        next = cursor.prev;
	        cursor.prev = prev;
	        prev = cursor;
	        cursor = next;
	    }

	    // init the cursor to start with 2nd item since 1st is a stub item
	    cursor = prev.prev;

	    // build a tree
	    while (cursor !== null && cursor.syntax !== null) {
	        var entry = cursor;

	        switch (entry.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: entry.syntax,
	                    match: []
	                });
	                stack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                stack.pop();
	                host = stack[stack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: entry.syntax || null,
	                    token: entry.token.value,
	                    node: entry.token.node
	                });
	        }

	        cursor = cursor.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list$$1) {
	                if (node === start) {
	                    var nodes = new list();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list$$1,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof list;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error$1.SyntaxReferenceError;
	var MatchError$1 = error$1.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords = buildMatchGraph$1(parse_1('inherit | initial | unset'));
	var cssWideKeywordsWithExpression = buildMatchGraph$1(parse_1('inherit | initial | unset | <expression>'));

	function dumpMapSyntax(map, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst ? map[name].syntax : generate_1(map[name].syntax);
	        }
	    }

	    return result;
	}

	function valueHasVar(value) {
	    var hasVar = false;

	    this.syntax.walk(value, function(node) {
	        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
	            hasVar = true;
	        }
	    });

	    return hasVar;
	}

	function buildMatchResult(match$$1, error, iterations) {
	    return {
	        matched: match$$1,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, node, useCommon) {
	    if (!node) {
	        return buildMatchResult(null, new Error('Node is undefined'));
	    }

	    if (valueHasVar.call(lexer, node)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    var tokens = lexer.syntax.generate(node, astToTokens);
	    var result;

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, lexer, syntax.syntax, node, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure$$1) {
	    this.valueCommonSyntax = cssWideKeywords;
	    this.syntax = syntax;
	    this.generic = false;
	    this.properties = {};
	    this.types = {};
	    this.structure = structure$$1 || getStructureFromConfig(config);

	    if (config) {
	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure$$1 = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure$$1.hasOwnProperty(node.type)) {
	                structure$$1[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic.expression) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (!syntax || !syntax.type) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (!syntax.match) {
	            syntax = this.createDescriptor(syntax);
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var grammar = {
	    SyntaxParseError: error$2.SyntaxParseError,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var TYPE$3 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$3.WhiteSpace;
	var COMMENT$2 = TYPE$3.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var noop$3 = function() {};

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new tokenizer(),
	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new list();
	        },
	        createSingleNodeList: function(node) {
	            return new list().appendData(node);
	        },
	        getFirstListNode: function(list$$1) {
	            return list$$1 && list$$1.first();
	        },
	        getLastListNode: function(list$$1) {
	            return list$$1.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.currentToken;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.scanner.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list$$1) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list$$1);
	                var tail = this.getLastListNode(list$$1);
	                return this.scanner.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        parser.scanner.setSource(source, options.offset, options.line, options.column);
	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.scanner.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};
	});
	var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
	var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
	var binarySearch_3 = binarySearch.search;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	var quickSort_1 = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort = {
		quickSort: quickSort_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$2 = arraySet.ArraySet;

	var quickSort$1 = quickSort.quickSort;

	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	var SourceMapConsumer_1 = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet$2.fromArray(names.map(String), true);
	  this._sources = ArraySet$2.fromArray(sources, true);

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64Vlq.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort$1(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }

	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet$2();
	  this._names = new ArraySet$2();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
	  };

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

	var sourceMapConsumer = {
		SourceMapConsumer: SourceMapConsumer_1,
		BasicSourceMapConsumer: BasicSourceMapConsumer_1,
		IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	var SourceNode_1 = SourceNode;

	var sourceNode = {
		SourceNode: SourceNode_1
	};

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
	var SourceNode$1 = sourceNode.SourceNode;

	var sourceMap = {
		SourceMapGenerator: SourceMapGenerator$2,
		SourceMapConsumer: SourceMapConsumer$1,
		SourceNode: SourceNode$1
	};

	var SourceMapGenerator$3 = sourceMap.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap$1 = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$3();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap$1(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof list === false) {
	                        node.children = new list().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof list) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = reverse ? config.fields.slice().reverse() : config.fields;
	    var body = fields.map(function(field) {
	        var ref = 'node.' + field.name;
	        var line;

	        if (field.type === 'list') {
	            line = reverse
	                ? ref + '.forEachRight(walk);'
	                : ref + '.forEach(walk);';
	        } else {
	            line = 'walk(' + ref + ');';
	        }

	        if (field.nullable) {
	            line = 'if (' + ref + ') {\n    ' + line + '}';
	        }

	        return line;
	    });

	    if (config.context) {
	        body = [].concat(
	            'var old = context.' + config.context + ';',
	            'context.' + config.context + ' = node;',
	            body,
	            'context.' + config.context + ' = old;'
	        );
	    }

	    return new Function('node', 'context', 'walk', body.join('\n'));
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    return function walk(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof list) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        var res = {};
	        for (var key in value) {
	            if (hasOwnProperty$5.call(value, key)) {
	                res[key] = value[key];
	            }
	        }
	        return res;
	    } else {
	        return value;
	    }
	}

	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function assign$1(dest, src) {
	    for (var key in src) {
	        dest[key] = src[key];
	    }

	    return dest;
	}

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: list,
	        Tokenizer: tokenizer,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        grammar: grammar,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        parse: parse,
	        walk: walk,
	        generate: generate,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, assign$1)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var appearance = {
		syntax: "auto | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var border = {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	};
	var opacity = {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var quotes = {
		syntax: "none | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var rotate = {
		syntax: "none | [ x | y | z | <number>{3} ]? && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-timing-function": {
		syntax: "<single-timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		appearance: appearance,
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		border: border,
		"border-block-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-bottom": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-inline-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-left": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-style": {
		syntax: "<br-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-width": {
		syntax: "<br-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-after": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-before": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		margin: margin,
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-block-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-block-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angle",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-style": {
		syntax: "auto | <br-style>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-width": {
		syntax: "<br-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overflow-inline": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		padding: padding,
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		scale: scale,
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-type": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"shape-image-threshold": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-timing-function": {
		syntax: "<single-transition-timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		default: properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"br-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"br-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color> <length-percentage>?"
	},
		"color-stop-list": {
		syntax: "<color-stop>#{2,}"
	},
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | subgrid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> {\n  <feature-value-declaration-list>\n}"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frames-timing-function": {
		syntax: "frames(<integer>)"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( [ [ <image> | <string> ]? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <border-radius> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number> [, <number> ]{5,5} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number> [, <number> ]{15,15} )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> {\n  <declaration-list>\n}"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( <angle> )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , <angle> )"
	},
		"rotateX()": {
		syntax: "rotateX( <angle> )"
	},
		"rotateY()": {
		syntax: "rotateY( <angle> )"
	},
		"rotateZ()": {
		syntax: "rotateZ( <angle> )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> [, <number> ]? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( <angle> [, <angle> ]? )"
	},
		"skewX()": {
		syntax: "skewX( <angle> )"
	},
		"skewY()": {
		syntax: "skewY( <angle> )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>"
	},
		"single-transition-timing-function": {
		syntax: "<single-timing-function>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, [ start | end ] ]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> [, <length-percentage> ]? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> [, <declaration-value> ]? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		attachment: attachment,
		box: box,
		color: color$1,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		default: syntaxes
	});

	var properties$3 = {
		"--*": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-line-clamp": {
			comment: "non-standard and deprecated but may still using by some sites",
			syntax: "<positive-integer>"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-mask-clip": {
			comment: "change type to <-webkit-mask-clip-style> since it differ from <mask-clip>, extra space between [ and ,",
			syntax: "<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			refenrences: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter>"
		},
		font: {
			comment: "extend with non-standard fonts",
			syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		"line-height-step": {
			comment: "fix extra spaces around",
			syntax: "none | <length>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "visible | hidden | scroll | auto | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"transform-origin": {
			comment: "move first group to the end since less collecting",
			syntax: "[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<unicode-range>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"word-break": {
			comment: "extend with non-standard keywords",
			syntax: "normal | break-all | keep-all | <-non-standard-word-break>"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to duoble sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			preferences: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-non-standard-word-break": {
			comment: "non-standard keywords https://css-tricks.com/almanac/properties/w/word-break/",
			syntax: "break-word"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter": {
			syntax: "[ <progid> | FlipH | FlipV ]+"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr()": {
			comment: "drop it since it's a generic",
			syntax: null
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"inset()": {
			comment: "changed <border-radius> to <'border-radius'>",
			syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added -webkit-gradient() since may to be used for legacy support",
			syntax: "<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"matrix()": {
			comment: "redundant max",
			syntax: "matrix( <number> [, <number> ]{5} )"
		},
		"matrix3d()": {
			comment: "redundant max",
			syntax: "matrix3d( <number> [, <number> ]{15} )"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "replaced <ident> to list of colors according to https://www.w3.org/TR/css-color-4/#named-colors",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		"outline-radius": {
			comment: "missed, looks like it's a similar to <border-radius> https://developer.mozilla.org/en/docs/Web/CSS/-moz-outline-radius",
			syntax: "<border-radius>"
		},
		paint: {
			comment: "simplified SVG syntax (omit <icccolor>, replace <funciri> for <url>) https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | currentColor | <color> | <url> [ none | currentColor | <color> ]?"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( [ [ <top>, <right>, <bottom>, <left> ] | [ <top> <right> <bottom> <left> ] ] )"
		},
		"single-transition": {
			comment: "moved <single-transition-timing-function> in the beginning to avoid wrong match to <single-transition-property>",
			syntax: "<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		"var()": {
			comment: "drop it since it's a generic (also syntax is incorrect and can't be parsed)",
			syntax: null
		},
		"an-plus-b": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"general-enclosed": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-plain": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-range": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-value": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-and": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-not": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-in-parens": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-feature": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition-without-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		nth: {
			comment: "syntax has <an-plus-b> that doesn't support currently, drop for now",
			syntax: null
		},
		"page-selector": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-selector-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-body": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"pseudo-page": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		properties: properties$3,
		syntaxes: syntaxes$2,
		default: patch
	});

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    properties: buildDictionary(mdnProperties, patch$2.properties),
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes)
	};

	var cmpChar$1 = tokenizer.cmpChar;
	var isNumber$3 = tokenizer.isNumber;
	var TYPE$4 = tokenizer.TYPE;

	var IDENTIFIER$3 = TYPE$4.Identifier;
	var NUMBER$2 = TYPE$4.Number;
	var PLUSSIGN$4 = TYPE$4.PlusSign;
	var HYPHENMINUS$4 = TYPE$4.HyphenMinus;
	var N$5 = 110; // 'n'.charCodeAt(0)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function checkTokenIsInteger(scanner, disallowSign) {
	    var pos = scanner.tokenStart;

	    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||
	        scanner.source.charCodeAt(pos) === HYPHENMINUS$4) {
	        if (disallowSign) {
	            scanner.error();
	        }
	        pos++;
	    }

	    for (; pos < scanner.tokenEnd; pos++) {
	        if (!isNumber$3(scanner.source.charCodeAt(pos))) {
	            scanner.error('Unexpected input', pos);
	        }
	    }
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = start;
	        var prefix = '';
	        var a = null;
	        var b = null;

	        if (this.scanner.tokenType === NUMBER$2 ||
	            this.scanner.tokenType === PLUSSIGN$4) {
	            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
	            prefix = this.scanner.getTokenValue();
	            this.scanner.next();
	            end = this.scanner.tokenStart;
	        }

	        if (this.scanner.tokenType === IDENTIFIER$3) {
	            var bStart = this.scanner.tokenStart;

	            if (cmpChar$1(this.scanner.source, bStart, HYPHENMINUS$4)) {
	                if (prefix === '') {
	                    prefix = '-';
	                    bStart++;
	                } else {
	                    this.scanner.error('Unexpected hyphen minus');
	                }
	            }

	            if (!cmpChar$1(this.scanner.source, bStart, N$5)) {
	                this.scanner.error();
	            }

	            a = prefix === ''  ? '1'  :
	                prefix === '+' ? '+1' :
	                prefix === '-' ? '-1' :
	                prefix;

	            var len = this.scanner.tokenEnd - bStart;
	            if (len > 1) {
	                // ..n-..
	                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$4) {
	                    this.scanner.error('Unexpected input', bStart + 1);
	                }

	                if (len > 2) {
	                    // ..n-{number}..
	                    this.scanner.tokenStart = bStart + 2;
	                } else {
	                    // ..n- {number}
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
	                b = '-' + this.scanner.getTokenValue();
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	            } else {
	                prefix = '';
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	                this.scanner.skipSC();

	                if (this.scanner.tokenType === HYPHENMINUS$4 ||
	                    this.scanner.tokenType === PLUSSIGN$4) {
	                    prefix = this.scanner.getTokenValue();
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                if (this.scanner.tokenType === NUMBER$2) {
	                    checkTokenIsInteger(this.scanner, prefix !== '');

	                    if (!isNumber$3(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
	                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
	                        this.scanner.tokenStart++;
	                    }

	                    if (prefix === '') {
	                        // should be an operator before number
	                        this.scanner.error();
	                    } else if (prefix === '+') {
	                        // plus is using by default
	                        prefix = '';
	                    }

	                    b = prefix + this.scanner.getTokenValue();

	                    this.scanner.next();
	                    end = this.scanner.tokenStart;
	                } else {
	                    if (prefix) {
	                        this.scanner.eat(NUMBER$2);
	                    }
	                }
	            }
	        } else {
	            if (prefix === '' || prefix === '+') { // no number
	                this.scanner.error(
	                    'Number or identifier is expected',
	                    this.scanner.tokenStart + (
	                        this.scanner.tokenType === PLUSSIGN$4 ||
	                        this.scanner.tokenType === HYPHENMINUS$4
	                    )
	                );
	            }

	            b = prefix;
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, end),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' :
	                node.a ===  '1' ?  'n' :
	                node.a === '-1' ? '-n' :
	                node.a + 'n'
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$5 = tokenizer.TYPE;

	var ATKEYWORD$2 = TYPE$5.AtKeyword;
	var SEMICOLON = TYPE$5.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$5.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$5.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET$2, false, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$2) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$2 ||
	            type === ATKEYWORD$2) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.scanner.eat(ATKEYWORD$2);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.currentToken);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$2:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$6 = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$6.Semicolon;
	var LEFTCURLYBRACKET$3 = TYPE$6.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.scanner.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$7 = tokenizer.TYPE;

	var IDENTIFIER$4 = TYPE$7.Identifier;
	var STRING$2 = TYPE$7.String;
	var DOLLARSIGN = TYPE$7.DollarSign;
	var ASTERISK$1 = TYPE$7.Asterisk;
	var COLON = TYPE$7.Colon;
	var EQUALSSIGN = TYPE$7.EqualsSign;
	var LEFTSQUAREBRACKET$2 = TYPE$7.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$7.RightSquareBracket;
	var CIRCUMFLEXACCENT = TYPE$7.CircumflexAccent;
	var VERTICALLINE$1 = TYPE$7.VerticalLine;
	var TILDE = TYPE$7.Tilde;

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.scanner.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdentifier = false;
	    var checkColon = true;

	    if (this.scanner.tokenType === ASTERISK$1) {
	        expectIdentifier = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    if (this.scanner.tokenType === VERTICALLINE$1) {
	        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.scanner.eat(IDENTIFIER$4);
	        } else if (expectIdentifier) {
	            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdentifier) {
	        this.scanner.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var tokenType = this.scanner.tokenType;

	    if (tokenType !== EQUALSSIGN &&        // =
	        tokenType !== TILDE &&             // ~=
	        tokenType !== CIRCUMFLEXACCENT &&  // ^=
	        tokenType !== DOLLARSIGN &&        // $=
	        tokenType !== ASTERISK$1 &&          // *=
	        tokenType !== VERTICALLINE$1         // |=
	    ) {
	        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    if (tokenType === EQUALSSIGN) {
	        this.scanner.next();
	    } else {
	        this.scanner.next();
	        this.scanner.eat(EQUALSSIGN);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' S* attrib_name ']'
	// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$2);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$2) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENTIFIER$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING$2
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENTIFIER$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.scanner.eat(RIGHTSQUAREBRACKET$2);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$8 = tokenizer.TYPE;

	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var COMMENT$3 = TYPE$8.Comment;
	var SEMICOLON$2 = TYPE$8.Semicolon;
	var ATKEYWORD$3 = TYPE$8.AtKeyword;
	var LEFTCURLYBRACKET$4 = TYPE$8.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$3 = TYPE$8.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, 0, 0, false, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$2, true, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.currentToken);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.scanner.eat(LEFTCURLYBRACKET$4);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$3:
	                    break scan;

	                case WHITESPACE$3:
	                case COMMENT$3:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$3:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTCURLYBRACKET$3);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$9 = tokenizer.TYPE;
	var LEFTSQUAREBRACKET$3 = TYPE$9.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$3 = TYPE$9.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$3);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTSQUAREBRACKET$3);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC$2 = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDC$2); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO$2 = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDO$2); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$a = tokenizer.TYPE;
	var IDENTIFIER$5 = TYPE$a.Identifier;
	var FULLSTOP$2 = TYPE$a.FullStop;

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(FULLSTOP$2);

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$b = tokenizer.TYPE;

	var PLUSSIGN$5 = TYPE$b.PlusSign;
	var SOLIDUS = TYPE$b.Solidus;
	var GREATERTHANSIGN$2 = TYPE$b.GreaterThanSign;
	var TILDE$1 = TYPE$b.Tilde;

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        switch (this.scanner.tokenType) {
	            case GREATERTHANSIGN$2:
	            case PLUSSIGN$5:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();
	                this.scanner.expectIdentifier('deep');
	                this.scanner.eat(SOLIDUS);
	                break;

	            default:
	                this.scanner.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$c = tokenizer.TYPE;

	var ASTERISK$2 = TYPE$c.Asterisk;
	var SOLIDUS$1 = TYPE$c.Solidus;

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        this.scanner.next();

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$d = tokenizer.TYPE;

	var IDENTIFIER$6 = TYPE$d.Identifier;
	var COLON$1 = TYPE$d.Colon;
	var EXCLAMATIONMARK$2 = TYPE$d.ExclamationMark;
	var SOLIDUS$2 = TYPE$d.Solidus;
	var ASTERISK$3 = TYPE$d.Asterisk;
	var DOLLARSIGN$1 = TYPE$d.DollarSign;
	var HYPHENMINUS$5 = TYPE$d.HyphenMinus;
	var SEMICOLON$3 = TYPE$d.Semicolon;
	var PLUSSIGN$6 = TYPE$d.PlusSign;
	var NUMBERSIGN$2 = TYPE$d.NumberSign;

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.currentToken;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.tokenType !== EXCLAMATIONMARK$2 &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.scanner.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.currentToken;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.scanner.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.currentToken);
	        }

	        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {
	            important = getImportant(this.scanner);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.scanner.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;
	    var prefix = 0;

	    // hacks
	    switch (this.scanner.tokenType) {
	        case ASTERISK$3:
	        case DOLLARSIGN$1:
	        case PLUSSIGN$6:
	        case NUMBERSIGN$2:
	            prefix = 1;
	            break;

	        // TODO: not sure we should support this hack
	        case SOLIDUS$2:
	            prefix = this.scanner.lookupType(1) === SOLIDUS$2 ? 2 : 1;
	            break;
	    }

	    if (this.scanner.lookupType(prefix) === HYPHENMINUS$5) {
	        prefix++;
	    }

	    if (prefix) {
	        this.scanner.skip(prefix);
	    }

	    this.scanner.eat(IDENTIFIER$6);

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant(scanner) {
	    scanner.eat(EXCLAMATIONMARK$2);
	    scanner.skipSC();

	    var important = scanner.consume(IDENTIFIER$6);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$e = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$4 = TYPE$e.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$4, true, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$4:
	                case COMMENT$4:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var NUMBER$3 = tokenizer.TYPE.Number;

	// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
	function readUnit(scanner) {
	    var unit = scanner.getTokenValue();
	    var backSlashPos = unit.indexOf('\\');

	    if (backSlashPos > 0) {
	        // patch token offset
	        scanner.tokenStart += backSlashPos;

	        // return part before backslash
	        return unit.substring(0, backSlashPos);
	    }

	    // no backslash in unit name
	    scanner.next();

	    return unit;
	}

	// number ident
	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value = this.scanner.consume(NUMBER$3);
	        var unit = readUnit(this.scanner);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value,
	            unit: unit
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$f = tokenizer.TYPE;
	var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

	// <function-token> <sequence> ')'
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.scanner.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$3);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var isHex$2 = tokenizer.isHex;
	var TYPE$g = tokenizer.TYPE;

	var IDENTIFIER$7 = TYPE$g.Identifier;
	var NUMBER$4 = TYPE$g.Number;
	var NUMBERSIGN$3 = TYPE$g.NumberSign;

	function consumeHexSequence(scanner, required) {
	    if (!isHex$2(scanner.source.charCodeAt(scanner.tokenStart))) {
	        if (required) {
	            scanner.error('Unexpected input', scanner.tokenStart);
	        } else {
	            return;
	        }
	    }

	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on non-hex char
	        if (!isHex$2(code)) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return;
	        }
	    }

	    // token is full hex sequence, go to next token
	    scanner.next();
	}

	// # ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(NUMBERSIGN$3);

	        scan:
	        switch (this.scanner.tokenType) {
	            case NUMBER$4:
	                consumeHexSequence(this.scanner, true);

	                // if token is identifier then number consists of hex only,
	                // try to add identifier to result
	                if (this.scanner.tokenType === IDENTIFIER$7) {
	                    consumeHexSequence(this.scanner, false);
	                }

	                break;

	            case IDENTIFIER$7:
	                consumeHexSequence(this.scanner, true);
	                break;

	            default:
	                this.scanner.error('Number or identifier is expected');
	        }

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1) // skip #
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$h = tokenizer.TYPE;
	var IDENTIFIER$8 = TYPE$h.Identifier;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;
	var IDENTIFIER$9 = TYPE$i.Identifier;
	var NUMBERSIGN$4 = TYPE$i.NumberSign;

	// '#' ident
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(NUMBERSIGN$4);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$9)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$j = tokenizer.TYPE;

	var IDENTIFIER$a = TYPE$j.Identifier;
	var NUMBER$5 = TYPE$j.Number;
	var LEFTPARENTHESIS$3 = TYPE$j.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$j.RightParenthesis;
	var COLON$2 = TYPE$j.Colon;
	var SOLIDUS$3 = TYPE$j.Solidus;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.scanner.eat(LEFTPARENTHESIS$3);
	        this.scanner.skipSC();

	        name = this.scanner.consume(IDENTIFIER$a);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
	            this.scanner.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$5:
	                    if (this.scanner.lookupType(1) === IDENTIFIER$a) {
	                        value = this.Dimension();
	                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case IDENTIFIER$a:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.scanner.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.scanner.eat(RIGHTPARENTHESIS$4);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$k = tokenizer.TYPE;

	var WHITESPACE$5 = TYPE$k.WhiteSpace;
	var COMMENT$5 = TYPE$k.Comment;
	var IDENTIFIER$b = TYPE$k.Identifier;
	var LEFTPARENTHESIS$4 = TYPE$k.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$5:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$5:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENTIFIER$b:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$4:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.scanner.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	// https://drafts.csswg.org/css-syntax-3/#the-anb-type
	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$6 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(NUMBER$6)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$l = tokenizer.TYPE;
	var LEFTPARENTHESIS$5 = TYPE$l.LeftParenthesis;
	var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTPARENTHESIS$5);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$5);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var NUMBER$7 = TYPE$m.Number;
	var PERCENTSIGN = TYPE$m.PercentSign;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var number = this.scanner.consume(NUMBER$7);

	        this.scanner.eat(PERCENTSIGN);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: number
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$n = tokenizer.TYPE;

	var IDENTIFIER$c = TYPE$n.Identifier;
	var FUNCTION$2 = TYPE$n.Function;
	var COLON$3 = TYPE$n.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$n.RightParenthesis;

	// : ident [ '(' .. ')' ]?
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$c);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENTIFIER$d = TYPE$o.Identifier;
	var FUNCTION$3 = TYPE$o.Function;
	var COLON$4 = TYPE$o.Colon;
	var RIGHTPARENTHESIS$7 = TYPE$o.RightParenthesis;

	// :: ident [ '(' .. ')' ]?
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$4);
	        this.scanner.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$3) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$7);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$d);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isNumber$4 = tokenizer.isNumber;
	var TYPE$p = tokenizer.TYPE;
	var NUMBER$8 = TYPE$p.Number;
	var SOLIDUS$4 = TYPE$p.Solidus;
	var FULLSTOP$3 = TYPE$p.FullStop;

	// Terms of <ratio> should to be a positive number (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without exponent part.
	// Additional checks may to be applied on lexer validation.
	function consumeNumber$1(scanner) {
	    var value = scanner.consumeNonWS(NUMBER$8);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isNumber$4(code) && code !== FULLSTOP$3) {
	            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$1(this.scanner);
	        var right;

	        this.scanner.eatNonWS(SOLIDUS$4);
	        right = consumeNumber$1(this.scanner);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(
	                startToken,
	                endTokenType1,
	                endTokenType2,
	                includeTokenType2
	            )
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = this.scanner.getOffsetExcludeWS();
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var LEFTCURLYBRACKET$5 = TYPE$q.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$5) {
	        this.scanner.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.currentToken;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.scanner.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var COMMA$2 = TYPE$r.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$3 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(STRING$3)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var WHITESPACE$6 = TYPE$s.WhiteSpace;
	var COMMENT$6 = TYPE$s.Comment;
	var EXCLAMATIONMARK$3 = TYPE$s.ExclamationMark;
	var ATKEYWORD$4 = TYPE$s.AtKeyword;
	var CDO$3 = TYPE$s.CDO;
	var CDC$3 = TYPE$s.CDC;

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, 0, 0, false, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$6:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$3: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$3: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$4:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$t = tokenizer.TYPE;

	var IDENTIFIER$e = TYPE$t.Identifier;
	var ASTERISK$4 = TYPE$t.Asterisk;
	var VERTICALLINE$2 = TYPE$t.VerticalLine;

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENTIFIER$e &&
	        this.scanner.tokenType !== ASTERISK$4) {
	        this.scanner.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.tokenType === VERTICALLINE$2) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.tokenType === VERTICALLINE$2) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHex$3 = tokenizer.isHex;
	var TYPE$u = tokenizer.TYPE;

	var IDENTIFIER$f = TYPE$u.Identifier;
	var NUMBER$9 = TYPE$u.Number;
	var PLUSSIGN$7 = TYPE$u.PlusSign;
	var HYPHENMINUS$6 = TYPE$u.HyphenMinus;
	var FULLSTOP$4 = TYPE$u.FullStop;
	var QUESTIONMARK$1 = TYPE$u.QuestionMark;

	function scanUnicodeNumber(scanner) {
	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on fullstop or hyperminus/plussign after exponent
	        if (code === FULLSTOP$4 || code === PLUSSIGN$7) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return false;
	        }
	    }

	    return true;
	}

	// https://drafts.csswg.org/css-syntax-3/#urange
	function scanUnicodeRange(scanner) {
	    var hexStart = scanner.tokenStart + 1; // skip +
	    var hexLength = 0;

	    scan: {
	        if (scanner.tokenType === NUMBER$9) {
	            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$4 && scanUnicodeNumber(scanner)) {
	                scanner.next();
	            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$6) {
	                break scan;
	            }
	        } else {
	            scanner.next(); // PLUSSIGN
	        }

	        if (scanner.tokenType === HYPHENMINUS$6) {
	            scanner.next();
	        }

	        if (scanner.tokenType === NUMBER$9) {
	            scanner.next();
	        }

	        if (scanner.tokenType === IDENTIFIER$f) {
	            scanner.next();
	        }

	        if (scanner.tokenStart === hexStart) {
	            scanner.error('Unexpected input', hexStart);
	        }
	    }

	    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
	    // where x is [0-9a-fA-F]
	    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
	        var code = scanner.source.charCodeAt(i);

	        if (isHex$3(code) === false && (code !== HYPHENMINUS$6 || wasHyphenMinus)) {
	            scanner.error('Unexpected input', i);
	        }

	        if (code === HYPHENMINUS$6) {
	            // hex sequence shouldn't be an empty
	            if (hexLength === 0) {
	                scanner.error('Unexpected input', i);
	            }

	            wasHyphenMinus = true;
	            hexLength = 0;
	        } else {
	            hexLength++;

	            // too long hex sequence
	            if (hexLength > 6) {
	                scanner.error('Too long hex sequence', i);
	            }
	        }

	    }

	    // check we have a non-zero sequence
	    if (hexLength === 0) {
	        scanner.error('Unexpected input', i - 1);
	    }

	    // U+abc???
	    if (!wasHyphenMinus) {
	        // consume as many U+003F QUESTION MARK (?) code points as possible
	        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
	            if (scanner.tokenType !== QUESTIONMARK$1) {
	                break;
	            }

	            hexLength++;
	        }
	    }
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next(); // U or u
	        scanUnicodeRange(this.scanner);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$v = tokenizer.TYPE;

	var STRING$4 = TYPE$v.String;
	var URL$3 = TYPE$v.Url;
	var RAW$2 = TYPE$v.Raw;
	var RIGHTPARENTHESIS$8 = TYPE$v.RightParenthesis;

	// url '(' S* (string | raw) S* ')'
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        this.scanner.eat(URL$3);
	        this.scanner.skipSC();

	        switch (this.scanner.tokenType) {
	            case STRING$4:
	                value = this.String();
	                break;

	            case RAW$2:
	                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);
	                break;

	            default:
	                this.scanner.error('String or Raw is expected');
	        }

	        this.scanner.skipSC();
	        this.scanner.eat(RIGHTPARENTHESIS$8);

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$7 = tokenizer.TYPE.WhiteSpace;
	var SPACE$4 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.scanner.eat(WHITESPACE$7);
	        return SPACE$4;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.scanner.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$w = tokenizer.TYPE;

	var IDENTIFIER$g = TYPE$w.Identifier;
	var STRING$5 = TYPE$w.String;
	var NUMBER$a = TYPE$w.Number;
	var FUNCTION$4 = TYPE$w.Function;
	var URL$4 = TYPE$w.Url;
	var NUMBERSIGN$5 = TYPE$w.NumberSign;
	var LEFTPARENTHESIS$6 = TYPE$w.LeftParenthesis;
	var LEFTSQUAREBRACKET$4 = TYPE$w.LeftSquareBracket;
	var PLUSSIGN$8 = TYPE$w.PlusSign;
	var HYPHENMINUS$7 = TYPE$w.HyphenMinus;
	var COMMA$3 = TYPE$w.Comma;
	var SOLIDUS$5 = TYPE$w.Solidus;
	var ASTERISK$5 = TYPE$w.Asterisk;
	var PERCENTSIGN$1 = TYPE$w.PercentSign;
	var BACKSLASH = TYPE$w.Backslash;
	var U = 117; // 'u'.charCodeAt(0)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case NUMBERSIGN$5:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case SOLIDUS$5:
	        case ASTERISK$5:
	        case PLUSSIGN$8:
	        case HYPHENMINUS$7:
	            return this.Operator();

	        case LEFTPARENTHESIS$6:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$4:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$5:
	            return this.String();

	        case NUMBER$a:
	            switch (this.scanner.lookupType(1)) {
	                case PERCENTSIGN$1:
	                    return this.Percentage();

	                case IDENTIFIER$g:
	                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
	                    if (cmpChar$2(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
	                        return this.Number();
	                    } else {
	                        return this.Dimension();
	                    }

	                default:
	                    return this.Number();
	            }

	        case FUNCTION$4:
	            return this.Function(this.readSequence, context.recognizer);

	        case URL$4:
	            return this.Url();

	        case IDENTIFIER$g:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$2(this.scanner.source, this.scanner.tokenStart, U) &&
	                cmpChar$2(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$8)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$x = tokenizer.TYPE;

	var IDENTIFIER$h = TYPE$x.Identifier;
	var NUMBER$b = TYPE$x.Number;
	var NUMBERSIGN$6 = TYPE$x.NumberSign;
	var LEFTSQUAREBRACKET$5 = TYPE$x.LeftSquareBracket;
	var PLUSSIGN$9 = TYPE$x.PlusSign;
	var SOLIDUS$6 = TYPE$x.Solidus;
	var ASTERISK$6 = TYPE$x.Asterisk;
	var FULLSTOP$5 = TYPE$x.FullStop;
	var COLON$5 = TYPE$x.Colon;
	var GREATERTHANSIGN$3 = TYPE$x.GreaterThanSign;
	var VERTICALLINE$3 = TYPE$x.VerticalLine;
	var TILDE$2 = TYPE$x.Tilde;

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case PLUSSIGN$9:
	        case GREATERTHANSIGN$3:
	        case TILDE$2:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Combinator();

	        case SOLIDUS$6:  // /deep/
	            return this.Combinator();

	        case FULLSTOP$5:
	            return this.ClassSelector();

	        case LEFTSQUAREBRACKET$5:
	            return this.AttributeSelector();

	        case NUMBERSIGN$6:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENTIFIER$h:
	        case ASTERISK$6:
	        case VERTICALLINE$3:
	            return this.TypeSelector();

	        case NUMBER$b:
	            return this.Percentage();
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression '(' raw ')'
	var expression$1 = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	};

	var TYPE$y = tokenizer.TYPE;

	var IDENTIFIER$i = TYPE$y.Identifier;
	var COMMA$4 = TYPE$y.Comma;
	var SEMICOLON$5 = TYPE$y.Semicolon;
	var HYPHENMINUS$8 = TYPE$y.HyphenMinus;
	var EXCLAMATIONMARK$4 = TYPE$y.ExclamationMark;

	// var '(' ident (',' <value>? )? ')'
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    var identStart = this.scanner.tokenStart;

	    this.scanner.eat(HYPHENMINUS$8);
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$8) {
	        this.scanner.error('HyphenMinus is expected');
	    }
	    this.scanner.eat(IDENTIFIER$i);

	    children.push({
	        type: 'Identifier',
	        loc: this.getLocation(identStart, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(identStart)
	    });

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$5, false, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression$1,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var STRING$6 = TYPE$z.String;
	var IDENTIFIER$j = TYPE$z.Identifier;
	var URL$5 = TYPE$z.Url;
	var LEFTPARENTHESIS$7 = TYPE$z.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$6:
	                    children.push(this.String());
	                    break;

	                case URL$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.scanner.error('String or url() is expected');
	            }

	            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$j ||
	                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$7) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$A = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$A.WhiteSpace;
	var COMMENT$7 = TYPE$A.Comment;
	var IDENTIFIER$k = TYPE$A.Identifier;
	var FUNCTION$5 = TYPE$A.Function;
	var LEFTPARENTHESIS$8 = TYPE$A.LeftParenthesis;
	var HYPHENMINUS$9 = TYPE$A.HyphenMinus;
	var COLON$6 = TYPE$A.Colon;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	}

	function parentheses() {
	    var index = 0;

	    this.scanner.skipSC();

	    // TODO: make it simplier
	    if (this.scanner.tokenType === IDENTIFIER$k) {
	        index = 1;
	    } else if (this.scanner.tokenType === HYPHENMINUS$9 &&
	               this.scanner.lookupType(1) === IDENTIFIER$k) {
	        index = 2;
	    }

	    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$8:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$7:
	                this.scanner.next();
	                continue;

	            case FUNCTION$5:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENTIFIER$k:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$8:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.scanner.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}

		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let href = node.value.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					node.value.value = url.toString();
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-bleed-top: 0;
	--pagedjs-bleed-right: 0;
	--pagedjs-bleed-bottom: 0;
	--pagedjs-bleed-left: 0;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}


.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

img {
	height: auto;
}

@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: var(--pagedjs-width);
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || 'get', url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials=='include';

			request.onload = () => {
	 			// Chrome returns a status code of 0 for local files
	 			const status = request.status === 0 && url.startsWith('file://') ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "mm"
			},
			height: {
				value: 14,
				unit: "mm"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "mm"
			},
			height: {
				value: 17,
				unit: "mm"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;

			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin : {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclartations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;


				if ((width && height) &&
						(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed);

					this.emit("size", { width, height, orientation, format, bleed });
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclartations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);
					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);
					} else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									default:
										// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;
		}

		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let {value, unit} = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					margins.push(node);
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages && !pages["*"].added) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
				pages["*"].added = true;
			}
			// Add :left & :right
			if (":left" in pages && !pages[":left"].added) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
				pages[":left"].added = true;
			}
			if (":right" in pages && !pages[":right"].added) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
				pages[":right"].added = true;
			}
			// Add :first & :blank
			if (":first" in pages && !pages[":first"].first) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
				pages[":first"].added = true;
			}
			if (":blank" in pages && !pages[":blank"].added) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
				pages[":blank"].added = true;
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth && !pages[pg].added) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
					pages[pg].added = true;
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name && !pages[pg].added) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
					pages[pg].added = true;
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};
			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());

			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}

			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);
				}
			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent$$1 = false;

				if(block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent$$1 = false;
							} else {
								hasContent$$1 = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
							 loc === "top-center" ||
							 loc === "top-right" ||
							 loc === "bottom-left" ||
							 loc === "bottom-center" ||
							 loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
							 loc === "left-middle" ||
							 loc === "left-bottom" ||
							 loc === "right-top" ||
							 loc === "right-middle" ||
							 loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent$$1
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if(content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(bleedTop, bleedRight, bleedBottom, bleedLeft, pageWidthVar, pageHeightVar);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			rules.push(wVar, hVar);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let dimensions = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});


			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if(centerWidth === "none" || centerWidth === "auto") {
						if(!leftContent && !rightContent){
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						}else if(leftContent){
							if(!rightContent){
								if(leftWidth !== "none" && leftWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							}else{
								if(leftWidth !== "none" && leftWidth !== "auto"){
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								}else{
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if(newcenterWidth > 40){
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										}else{
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						}else{
							if(rightWidth !== "none" && rightWidth !== "auto"){
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							}else{
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					}else if(centerWidth !== "none" && centerWidth !== "auto"){
						if(leftContent && leftWidth !== "none" && leftWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						}else if(rightContent && rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				}else{
					if(leftContent){
						if(!rightContent){
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						}else{
							if(leftWidth !== "none" && leftWidth !== "auto"){
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							}else{
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth  + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					}else{
						if(rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if(middleHeight === "none" || middleHeight === "auto") {
						if(!topContent && !bottomContent){
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						}else if(topContent){
							if(!bottomContent){
								if(topHeight !== "none" && topHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							}else{
								if(topHeight !== "none" && topHeight !== "auto"){
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									}else{
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								}else{
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						}else{
							if(bottomHeight !== "none" && bottomHeight !== "auto"){
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					}else{
						if(topContent && topHeight !== "none" && topHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = topHeight +" " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						}else if(bottomContent && bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				}else{
					if(topContent){
						if(!bottomContent){
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						}else{
							if(topHeight !== "none" && topHeight !== "auto"){
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							}else{
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					}else{
						if(bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator="+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child$$1 = declaration.value.children.first();
				let value = child$$1.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			splits.forEach((split) => {
				let ref = split.dataset.ref;
				let from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}

					this.handleAlignment(from);
				}
			});
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			if (align === "justify" && alignLast === "auto") {
				node.style["text-align-last"] = "justify";
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number: number || 1
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				this.addCounterValues(parsed, counter);
			}
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (var i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
				}
			}
		}

		addCounterValues(parsed, counter) {
			let counterName = counter.name;
			let elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;

			for (var i = 0; i < elements.length; i++) {
				element = elements[i];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					count = parseInt(reset);
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");

					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-reset: ${counterName} ${count} }`, this.styleSheet.cssRules.length);
					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-increment: ${counterName} ${increment}}`, this.styleSheet.cssRules.length);

					count += parseInt(increment);

					element.setAttribute("data-counter-"+counterName+"-value", count);
				}

			}
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				let value = reset.datasetCounterPageReset;
				this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-reset: page ${value} }`, this.styleSheet.cssRules.length);
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
				list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + 1);
			}
		}

	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier: identifier,
					value: value,
					selector: selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

				funcNode.children.append(funcNode.children.createItem({
					type: "Identifier",
					loc: null,
					name: "--pagedjs-string-" + identifier
				}));
			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.stringSetSelectors)) {
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					let cssVar;
					if (set.value === "content" || set.value === "content()" || set.value === "content(text)") {
						cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --pagedjs-string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--pagedjs-string-${name}`, `"${cssVar}"`);
						set.first = cssVar;
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					} else {
						console.warn(set.value + "needs css replacement");
					}
				} else {
					// Use the previous values
					if (set.first) {
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					}
				}
			}
		}
	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (var i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								pg += 1;

								if (pages[i].contains( element )){
									break;
								}
							}

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				selector.split(",").forEach((s) => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach((name) => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						if (target.style === "content") {
							let selector = UUID();
							selected.setAttribute("data-target-text", selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}

							let textContent = element.textContent.trim().replace(/["']/g, (match) => {
								return "\\" + match;
							}).replace(/[\n]/g, (match) => {
								return "\\00000A";
							});

							// this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { content: "${element.textContent}" }`, this.styleSheet.cssRules.length);
							this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { ${target.variable}: "${textContent}" }`, this.styleSheet.cssRules.length);

						}
					} else {
						console.warn("missed target", val);
					}
				});

			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		if (typeof Symbol !== 'function') return false;
		try { } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor() {
			// this.preview = this.getParams("preview") !== "false";

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker();

			// Hooks
			this.hooks = {};

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			let counter = 0;
			this.chunker.on("page", (page) => {
				counter += 1;
				this.emit("page", page);
				if (typeof window.PuppeteerLogger !== "undefined") {
					window.PuppeteerLogger("page", counter);
				}
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();
			let msg = "Rendering " + flow.total + " pages took " + (endTime - startTime) + " milliseconds.";

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			if (typeof window.onPagesRendered !== "undefined") {
				window.onPagesRendered(msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			}

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);



	var Paged = /*#__PURE__*/Object.freeze({
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined
	};

	let previewer = new Previewer(config.content, config.stylesheets, config.renderTo);


	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview();
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

}));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      const abbreviations = content.querySelectorAll('abbr');
      if(abbreviations.length === 0) return;
      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });
}
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>




<style type="text/css">



:root {
--background: whitesmoke;
--pagedjs-width: 210mm;
--pagedjs-height: 297mm;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
--main-color: #c78039;
--main-font: "Gelasio";
--header-font: "Inter";
}


@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}


@page {
size: 210mm 297mm; 
}

h1.title {
string-set: h1-title content(text);
}
.shorttitle1 {
string-set: h1-text content(text);
}

@page {
@top-left-corner {
content: "";
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-left {
content: string(h1-title);
font-family: "Inter";
font-weight: bold;
color: var(--main-color);
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-center {
content: "";
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-right {
content: string(h1-text);
font-family: "Inter";
color: var(--main-color);
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-right-corner {
content: "";
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
}

@page:left {

@bottom-right {
content: counter(page);
color: var(--main-color);
border: 5px solid var(--main-color);
margin-left: 15cm;
margin-right: -3cm;
padding-left: 1cm;
padding-right: 3cm;
margin-bottom: 1cm;
font-size: 14pt;
font-weight: bold;
}
}
@page:right {

@bottom-left {
content: counter(page);
color: var(--main-color);
border: 5px solid var(--main-color);
margin-right: 15cm;
margin-left: -3cm;
padding-right: 1cm;
padding-left: 3cm;
margin-bottom: 1cm;
font-size: 14pt;
font-weight: bold;
}
}

@page:first{
margin: 0 0 0 0;
background-color: #ffffff;
background-image: var(--front-cover), var(--front-cover-2);
background-repeat: no-repeat, no-repeat;
background-position: 15cm 23cm, 0cm 0cm;
background-size: 4cm, cover;
@top-left-corner {
display: none;
}
@top-left {
display: none;
}
@top-center {
display: none;
}
@top-right {
display: none;
}
@top-right-corner {
display: none;
}
@bottom-right {
display: none;
}
@bottom-left {
display: none;
}
}

.pagedjs_page:last-of-type {
margin: 0 0 0 0;
background-color: var(--main-color);
background-image: var(--back-cover);
background-repeat: no-repeat;
background-position: 15cm 23cm;
background-size: 4cm;
}

.pagedjs_page:last-of-type .pagedjs_margin.pagedjs_margin-bottom-right {
display: none;
}

@font-face {
font-family: 'Gelasio';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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CpMKIQAAAAcAAgAAAAAAAAgAAQAEsAAAAAAAAAHuAAAB7gAABV7/5QU7ADkFIwBBBf4AYAU6AGAEywBgBc0AVAaFAGADHgBsBCQALAWOAGAE1ABgB2sAUQYjADUF9ABeBOEAYAX0AF4FnQBgBH0AbgTzACcGDQBKBVX/2gfO//wFrwANBOz/1ATQAEEECABhBHv/5AOiAEUEmABcA94ARQKaADgEEwA5BKgAEAJYAC4CVv/NBEkABgJKAAIHDAAvBLoALQRQAE0EkgALBHoAXANHAD0DdQBEAsMAHgSaADED+f/eBeb/zgQKAA8D8P/tA40AIgVe/+UFXv/lBV7/5QVe/+UFXv/lBV7/5QfE/58FIwBBBf4AXwU6AGAFOgBgBToAYAU6AGADHgBsAx4AOQMeAEoDHgBsBiMANQX0AF4F9ABeBfQAXgX0AF4F9ABeBfQAXgf8AF4E6gBgBg0ASgYNAEoGDQBKBg0ASgTs/9QECABhBAgAYQQIAGEECABhBAgAYQQIAGEF5QBhA6IARQPeAEUD3gBFA94ARQPeAEUEQQBGAlgALgJY/+ECWP/yAlgALgJYAC4CWP/yAlb/zQS6AC0EUABNBFAATQRQAE0EUABNBFAATQRQAE0GiABGBHn/5ASaADEEmgAxBJoAMQSaADED8P/tA/D/7QRjABIE9gA/BKkAGAS4ABgHEgA/BxIAKgWvAEgHbgCIA8cASgeJAEYHiQBGB4oAEwUlAHsFJQDEBAABSAQAAR4EAAC7BAAAggQAALMFJf/7AdAAdgQAAP4B3gAKAAD9KwAA/QAAAPy7AAD+lAAA/4cAAP68AAD+6AL+AGoC/gBqBSUAagbbAGoFJf/nAigAiAIoAHkCgADPAoAAowKmAMcCpgC+A9QARwPUAE4GdQDXAjwAkgFVAB4DJACRA8AArgPAADEDAAE4AwABOAMAAF8DAABaAwAAqgMAAJwDcQBIA3EAPAG5AIgDSwCaAdAAVwHQAFwDSABQA0gAWgHQAFEDSABAA1IArwNSAMoEpgB1BKYAhgQAACgFJQBjBOkAkANwAJYEeABxBGoAWwSFADkEOgBABIcAYAQFAEMExQCLBIcAYACm/p0DwAErCGYAUAhmAFcIZgC0A1sAWgaKAG0FJQCtBSUAyQUlAMMFJQDBBSUAwwUlAKoFJQDSBSUBBQUlAL4EAABs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WUJCIyBHsAZDsAJiILAAUFiwQGBZZrABY2AgsAErIIqKYSCwBENgZCOwBUNhZFBYsARDYRuwBUNgWbADJbACYiCwAFBYsEBgWWawAWNhsAIlRmE4IyA8IzgbISAgRiNHsAErI2E4IVmxMAEUKy2wRyyxADorLrEwARQrLbBILLEAOyshIyAgPLAGI0IjOLEwARQrsAZDLrAwKy2wSSywABUgR7AAI0KyAAEBFRQTLrA2Ki2wSiywABUgR7AAI0KyAAEBFRQTLrA2Ki2wSyyxAAEUE7A3Ki2wTCywOSotsE0ssAAWRSMgLiBGiiNhOLEwARQrLbBOLLAKI0KwTSstsE8ssgAARistsFAssgABRistsFEssgEARistsFIssgEBRistsFMssgAARystsFQssgABRystsFUssgEARystsFYssgEBRystsFcsswAAAEMrLbBYLLMAAQBDKy2wWSyzAQAAQystsFosswEBAEMrLbBbLLMAAAFDKy2wXCyzAAEBQystsF0sswEAAUMrLbBeLLMBAQFDKy2wXyyyAABFKy2wYCyyAAFFKy2wYSyyAQBFKy2wYiyyAQFFKy2wYyyyAABIKy2wZCyyAAFIKy2wZSyyAQBIKy2wZiyyAQFIKy2wZyyzAAAARCstsGgsswABAEQrLbBpLLMBAABEKy2waiyzAQEARCstsGssswAAAUQrLbBsLLMAAQFEKy2wbSyzAQABRCstsG4sswEBAUQrLbBvLLEAPCsusTABFCstsHAssQA8K7BAKy2wcSyxADwrsEErLbByLLAAFrEAPCuwQistsHMssQE8K7BAKy2wdCyxATwrsEErLbB1LLAAFrEBPCuwQistsHYssQA9Ky6xMAEUKy2wdyyxAD0rsEArLbB4LLEAPSuwQSstsHkssQA9K7BCKy2weiyxAT0rsEArLbB7LLEBPSuwQSstsHwssQE9K7BCKy2wfSyxAD4rLrEwARQrLbB+LLEAPiuwQCstsH8ssQA+K7BBKy2wgCyxAD4rsEIrLbCBLLEBPiuwQCstsIIssQE+K7BBKy2wgyyxAT4rsEIrLbCELLEAPysusTABFCstsIUssQA/K7BAKy2whiyxAD8rsEErLbCHLLEAPyuwQistsIgssQE/K7BAKy2wiSyxAT8rsEErLbCKLLEBPyuwQistsIsssgsAA0VQWLAGG7IEAgNFWCMhGyFZWUIrsAhlsAMkUHixBQEVRVgwWS0AAAAAS7gAyFJYsQEBjlmwAbkIAAgAY3CxAAdCtQAAMCAEACqxAAdCQAo9BDUEJQgVCAQKKrEAB0JACkECOQItBh0GBAoqsQALQr0PgA2ACYAFgAAEAAsqsQAPQr0AQABAAEAAQAAEAAsquQADAABEsSQBiFFYsECIWLkAAwBkRLEoAYhRWLgIAIhYuQADAABEWRuxJwGIUVi6CIAAAQRAiGNUWLkAAwAARFlZWVlZQAo/AjcCJwYXBgQOKrgB/4WwBI2xAgBEswVkBgBERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyADIAMgAyBagAAAXkA+MAAP5CBagAAAXkBaj/4/5CANgA2ABfAF8FiwAABhYD4gAA/lYFqf/jBhYD9v/j/j8AxADEAEIAQgLc/xQC6v77AMQAxABCAEIGvQL1BswC3AAAAAAACABmAAMAAQQJAAAApAAAAAMAAQQJAAEADgCkAAMAAQQJAAIADgCyAAMAAQQJAAMANADAAAMAAQQJAAQAHgD0AAMAAQQJAAUAGgESAAMAAQQJAAYAHgEsAAMAAQQJAA4ANAFKAEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADEAOQAgAFQAaABlACAARwBlAGwAYQBzAGkAbwAgAFAAcgBvAGoAZQBjAHQAIABBAHUAdABoAG8AcgBzACAAKABoAHQAdABwAHMAOgAvAC8AZwBpAHQAaAB1AGIALgBjAG8AbQAvAFMAbwByAGsAaQBuAFQAeQBwAGUALwBHAGUAbABhAHMAaQBvACkARwBlAGwAYQBzAGkAbwBSAGUAZwB1AGwAYQByADEALgAwADAANgA7AFMAVABDACAAOwBHAGUAbABhAHMAaQBvAC0AUgBlAGcAdQBsAGEAcgBHAGUAbABhAHMAaQBvACAAUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMQAuADAAMAA2AEcAZQBsAGEAcwBpAG8ALQBSAGUAZwB1AGwAYQByAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAACAAAAAAAA/3cAagAAAAAAAAAAAAAAAAAAAAAAAAAAAQ8AAAECAAIAAwEDACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AyQDHAGIArQBjAK4AkABkAOkAZQDIAMoAywDMAM0AzgDPAGYA0ADRAGcA0wCRAK8AsADtANQA1QBoANYA6wBpAGsAbABqAG4AbQCgAG8AcAByAHMAcQDqAHQAdgB3AQQA1wB1AQUAeAB5AHsAfAB6AKEAfQCxAO4AfgCAAIEAfwDsALoAiQEGAMAAwQEHAQgACQAjAA0AiwCKAIwAQQBhAEMAjQDYANkAjgDaAQkA3QDeAQoBCwEMAQ0BDgEPARABEQAQALIAswBCABEADwAdAB4ABACjACIAogCrAMMBEgCHABIAPwBfAOgACwAMAD4AQABeAGAACgAFALYAtwC0ALUAxADFAL4AvwCpAKoAiAAGABMAFAAVABYAFwAYABkAGgAbABwAvAETAPUA9AD2AIMACAAOAO8AkwAgAPAAHwAhALgApACGARQAvQAHAIQAhQCWARUBFgEXARgAnQCeARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AAEBPQROVUxMB3VuaTAwQTAJaS5sb2NsVFJLB3VuaTAyMzcDZl9mBWZfZl9pBWZfZl9sB3VuaTAyQkMJZ3JhdmVjb21iCWFjdXRlY29tYgd1bmkwMzAyCXRpbGRlY29tYgd1bmkwMzA3B3VuaTAzMDgHdW5pMDMwQQd1bmkwMEFEFnBlcmlvZGNlbnRlcmVkLmxvY2xDQVQHdW5pMjIxNQRFdXJvB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQHdW5pMDBCNQ5ncmF2ZWNvbWIuY2FzZQ5hY3V0ZWNvbWIuY2FzZQx1bmkwMzAyLmNhc2UOdGlsZGVjb21iLmNhc2UMdW5pMDMwOC5jYXNlG3BlcmlvZGNlbnRlcmVkLmxvY2xDQVQuY2FzZQl6ZXJvLmRub20Ib25lLmRub20IdHdvLmRub20KdGhyZWUuZG5vbQlmb3VyLmRub20JZml2ZS5kbm9tCHNpeC5kbm9tCnNldmVuLmRub20KZWlnaHQuZG5vbQluaW5lLmRub20JemVyby5udW1yCG9uZS5udW1yCHR3by5udW1yCnRocmVlLm51bXIJZm91ci5udW1yCWZpdmUubnVtcghzaXgubnVtcgpzZXZlbi5udW1yCmVpZ2h0Lm51bXIJbmluZS5udW1yB3VuaTAyQkIHdW5pMjAwOQd1bmkyMDBCBnNlY29uZAdhcnJvd3VwCWFycm93ZG93bgt1bmkwMEE0MDMwMQt1bmkwMDZBMDMwMQd1bmkwM0JDBm1pbnV0ZQABAAH//wAPAAEAAAAMAAAAOgAAAAIABwAFAFAAAQBTAGMAAQBlAGoAAQBsAHMAAQB1AHoAAQB8AIAAAgEKAQsAAQAOAAUAGAAgACgAMAA+AAIAAQB8AIAAAAABAAQAAQJwAAEABAABAoMAAQAEAAECbwACAAYACgABAlcAAQTbAAIABgAKAAECUgABBNIAAAABAAAACgAcAB4AAURGTFQACAAEAAAAAP//AAAAAAAAAAEAAAAKAPoCSgACREZMVAAObGF0bgAgAAQAAAAA//8ABAAAAAoAFAAnADoACUFaRSAASENBVCAAWENSVCAAaEtBWiAAeE1PTCAAiE5MRCAAmFJPTSAAoFRBVCAAsFRSSyAAwAAA//8ABAABAAsAFQAoAAD//wAFAAIADAAWAB4AKQAA//8ABQADAA0AFwAfACoAAP//AAUABAAOABgAIAArAAD//wAFAAUADwAZACEALAAA//8ABQAGABAAGgAiAC0AAP//AAEAIwAA//8ABQAHABEAGwAkAC4AAP//AAUACAASABwAJQAvAAD//wAFAAkAEwAdACYAMAAxZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZG5vbQEoZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEuZnJhYwEubGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bGlnYQE4bG9jbAFEbG9jbAE+bG9jbAFEbG9jbAFEbG9jbAFEbG9jbAE+bG9jbAFEbG9jbAFEbG9jbAFEbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKbnVtcgFKAAAAAQADAAAAAwAEAAUABgAAAAEABwAAAAEAAQAAAAEAAAAAAAEAAgALABgANADUALIAwADUAOwBKgFuAYwBoAABAAAABQAQABAAEAAQABAAAQAGAEEAAQABACcABgAAAAQADgAsAEoAZAADAAEAEgABABgAAAABAAAACAABAAEAZQABAAEAKAADAAEAEgABABgAAAABAAAACAABAAEARgABAAEADgADAAEAFAABARwAAQAUAAEAAAAIAAEAAQAqAAMAAQAUAAEBAgABABQAAQAAAAkAAQABABAAAQAAAAEACAABACgALgABAAAAAQAIAAEABgAiAAEAAQCqAAEAAAABAAgAAQAGADgAAgABAMIAywAAAAYAAAACAAoAIgADAAEAEgABALgAAAABAAAACgABAAEAzAADAAEAEgABAKAAAAABAAAACgACAAEA8AD5AAAABAAAAAEACAABADYAAQAIAAUADAAUABwAIgAoAH8AAwAkACcAgAADACQAKgB8AAIAJAB9AAIAJwB+AAIAKgABAAEAJAABAAAAAQAIAAIADAADAQoBCwCoAAEAAwAOACgApwABAAAAAQAIAAEABgBIAAEAAQCnAAEAAAABAAgAAQAG//YAAgABAPoBAwAAAAA=) format('truetype');
}
@font-face {
font-family: 'Inter';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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BwQAoAYkAJAGCAAoBvAAsAdQAEgG4ACoBRwArAaoANQHAADQBxAApAawANgG3AC0BkgAiAbIAKsG3AC0BwgAkAMQANQDEADUBZQAcAWUAIwD/AEsA/wAhAP8AUwD/ABgA/wAaAP8AGAKTACIA/wBLAP8AIQD/AFMA/wAYAP8AGgD/ABgCkwAiAbwADAH9ACkA+wAQAOYAWgC7AEIA+wAQAUQAMgFEADIBYAAAAsAAAAGMAFgBRAAyAWAAAALAAAABjABYAIwAIgCCAAsAnAALAJwAMgEcADIBDAAiAQwACwEMAAsAjAAKAJsAIwEdACMAxQAvAMIANAJCADQAwgA0AMIANADFAC8AwgA0APwALwD8AC8BfAAvAXwALwHQAEcB0ABHAdAATgHQAEMB0ABIAdAASAHQAEgB0ABHAdAAOUHQAEcB0ABHAdAATgHQAEMB0ABIAdAASAHQAEgB0ABHAdAAOUF8AC8BPj//AUoAHAFgACcBYAAnAdgAJAKEADnBrAAcAUAALQE8AC8BPAAnAHgAHgEcACEBpgAmAYQAJADcgBwBKAAhAS8AHgEzABoBGgAXAMWAGAEPAB0BEgAaARYAFwEKAB0BDwAXAPcAEgETABcBDwAYAME/lAEaABcAxYAYAQ8AHQESABoBFgAXAQoAHQEPABcA9wASARMAFwEPABgBGgAoARoAKAEZAC4ApQAqAKUAEAEaABcAxYAYAQ8AHQESABoBFgAXAQoAHQEPABcA9wASARMAFwEPABgBGgAoARoAKAEZAC4ApQAqAKUAEAEaABcAxYAYAQ8AHQESABoBFgAXAQoAHQEPABcA9wASARMAFwEPABgCjAAYAm4AGAKcABoCPAA7AV4AjAFeAG4BoABgAUAANAFgADUBPAApAKgAKgDcABMAvAA8AMYAAADGAAABYAAAAIAAAAAAAAACoABFg7AARYdgAEWDsABFgqAAWAOwAFgHYABYAqAAWAOwAFgDsABFhNAARYOwAEWE0ABFgqAAb4KgAHACoABFg7AARYdgAEWDsABFgqAAWAOwAFgHYABYAqAAWAOwAFgDsABFhNAARYOwAEWE0ABFgfo/7wGMAD4AAAAAALwAKwE8ADABoABgATwAIwDcABsAAEAAAqo/VgAAB2A9+D09BxqAAEAAAAAAAAAAAAAAAAAAAFOAAQHLgGQAAUAAAcm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AAAAAAAAAAD/UAAAAAAAAAAA/zD/cP9w/1AAAAAAAAAAAAAAAAAAAAAAAAD/0AAAAAAAAAAA/+D/oAAAAAAAAAAA/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAD/oP/IAAAAAP/gAAAAAAAAAAAAAP8QAAAAAAAAAAD/UAAAAAAAAAAA/5D/cP9w/7AAAAAAAAAAAAAAAAAAAAAAAAAAAP/gAAAAAAAAAAAAAAAAAAAAAP/M/8AAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+0AAAAAAAAAAA/6AAAAAA/nAAAAAAAAAAAP7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/gAAAAAAAAP+gAAAAAAAA/5D/oAAAAAAAAAAA/6z/oAAA/+AAAAAAAAAAAAAAAAAAAAAAAAAAAP/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/IAAAAAAAAAAAAAAAAAAAAAP8wAAAAAAAAAAD/gAAAAAAAAAAA/4D/cP9wAAAAAAAAAAAAAAAAAAAAAAAA/5AAAP/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9wAAAAAAAAAAAAAAAAAAAAAP7AAAAAAAAAAAAAAAAAAAAAAAAA/qD+8P8AAAAAAAAAAAAAAAAAAAAAAACw/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6D/AAAAAAAAAP9wAAAAAAAAABD/MP9A/yAAAAAAAAAAAAAAAAAAAP8w/6D/oP8gAAD+kP7gAAAAAAAA/xD/QP9gAAAAAAAAAAAAAAAAAAAAgAAA/6D/5P84AAAAAP+gAAAAAAAAAAAAAP9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/QAAAAAAAAAAAAAAAAAAAAAP8QAAAAAAAAAAAAAAAAAAAAAAAA/3D/cP9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/QAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/oAAAAAAAAAAAAAAAAAAA/yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYABgAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/3AAAAAAAAAAAAAAAAAAAP+QAAAAAAAAAAAAAAAAAAAAAP7wAAAAAAAAAAD/YAAAAAAAAAAAAAD/QP9Q/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9gAAAAAAAAAAD/kAAoAAAAAAAA/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+gAAAAAAAA/zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/IAAAAAP9w/0D/0P+QAAAAAAAAAAAAAAAAAAAAAAAAAAD/oAAAAAAAAP+g/5AAAAAA/yAAAABkAAAAAP9Q/6AAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYP7wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9QAAAAAAAAAAAAAAAAAAAAAAAA/zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/wAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+gAAAAAP8YAAAAAP9g/7gAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wz/cAAAAAAAAAAA/7QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/IP8o/6AAAP7A/zD/OP7w/5D/kAAAAAAAAAAAAAAAAAAA/1D/oAAAAAAAAAAA/wD/UAAA/tAAAAAAAAAAAP+gAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/o/0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/gAAAAAAAAAAA/6D/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/wAAAAAAAAAAA/6AAAAAA/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9QAAAAAAAAAAAAAAAAAAAAAAAA/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAP+gAAAAAAAAAAAAAAAAAAAAAP8AAAAAAAAAAAD/EAAAAAAAAAAA/pD/UP9g/5D/oAAAAAAAAAAAAAAAAAAA/5AAAAAAAAAAAAAA/4D/cAAAAAAAAP+g/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/uAAAAAAAAP+gAAAAAAAA/3D/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+8AAAAAAAAAAAAAAAAAAAAAAAAP9wAAAAAAAAAAAAAAAAAAAAAP7QAAAAAAAAAAD+oP7wAAAAAAAA/vD/AP9QAAAAAAAAAAAAAAAAAAAAAAAA/0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/EAAAAAAAAAAAAAAAAAAA/qAAAAAAAAAAAP5gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/UP9QAAAAAAAA/oD/YP9g/8T/kAAAAAAAAAAoAAAAAAAA/2D94AAAAAAAAAAA/xAAAAAA/fAAAAAA/4AAAP6gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4AAA/ygAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+QAAAAAP9g/wAAAAAA//D/oAAAAAAAAP+gAAAAAAAAAAD/kAAAAAAAAAAAAAAAAAAA/rAAAAAAAAAAAP9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/oAAAAAAAAAAAAAAAAAAA/8AAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGD/wAAA//AAAAAAAAAAAAAAAAAAYABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+0P+Q/6AAAAAAAAAAAP+gAAD/oAAAAGAAAP+QAAAAAAAAAAAAAAAAAAAAAAAA/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAP/WAAAAAAAAAAAAAAAAAAAAAP9QAAAAAAAAAAD/EAAA/7D+UAAAAIAAAAAAAAAAAAAAAAD+8P9A/pAAAAAAAAAAAAAAAAAAAP+g/1AAAP8AAAD/EP+QAAAAAAAA/vD/QAAAAAAAAAAAAAAAAAAAAAAAAAAA/4AAAP8cAAAAAP/AAAAAAAAAAAAAAAAAAAAAAAAAAAD/gP/wAAAAAP8g/zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/kAAAAAAAAAAAAAAAAAAA/nAAAAAAAAAAAP7wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/0AAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/MP8g/6wAAP6g/xD/MAAA/2D/MAAAAAAAAP9QAAAAAAAA/6D/oAAAAAAAAAAA/pD/cAAA/rAAAAAAAAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAA/zAAAAAAAAAAAAAAAAAAAP9Q/1D/gAAAAAD/cP9w/6AAAP7w/1D/cP9QAAAAAAAAAAAAAAAAAAAAAAAA/1D+8AAAAAAAAAAA/2AAAAAA/sAAAAAAAAAAAP7wAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/cP9w/6AAAP8A/2D/cP9Q/6AAAAAAAAAAAAAAAAAAAAAA/3D+8AAAAAAAAAAA/2AAAAAA/tAAAAAAAAAAAP9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/QP+w/+AAAAAAAAAAAP9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/kAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/sP/AAAAAQP+Q/6D/1AAAAAAAAP/AAAAAAAAAAAAAAAAAAAD/YAAAAAAAAAAc/5AAAAAA/wAAAAAAAAAAAP9QAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAA/8D/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+QAAP/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA8AAAAAABAABwAAAAAAAAAAAAcP9gAIAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAD/gP/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/3AAAAAAAAAAAAAAAAAAAAAA/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/iAAAAAAAAAAAAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/kP/QAAAAgP9w/5AAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAD/UAAAAAAAAAAAAAAAAAAA/yAAAAAwAAAAAP9g/2AAAAAAAAD/oABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAYABgAAAAAAAAAAP+w//AAAAAA/zj/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/oAAAAAAAAAAAAAAAAAAAAAP84AAAAAAAA/+wAAAAA/3QAAAAAAAAAAAAAAAAAAAAA/+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8wAAAAAAAA/3D/cAAAAAAAAAAA/zD/gP+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9AAAAAAAAAAAAAAAAAAAAAAACD/yP/wAAAAAABgAAAAAAAAAAAAAP/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/UAAAAAAAAAAD/kABQAAAAAAAA/6D/5P/kAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAA/+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+0AAAAAAAAAAAAAAAAAAP/MAAAAAAAA/0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/MAAAAAAAAAAA/6AAAAAA/yAAAAB4AAAAAP9g/3AAAAAAAAD/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/wP/AAAAAAAAAAAAAAP+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAA/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACACEAAQAMAAAADgBSAAwAVAB1AFEAdwB6AHMAfgCCAHcAhQCHAHwAjQCSAH8AlACUAIUAlgCWAIYAmACYAIcAngCeAIgAoQCiAIkApgCmAIsAqgCrAIwArQCyAI4AtQC4AJQAugC/AJgAwgDEAJ4AxgDIAKEAywDNAKQAzwDRAKcA1ADVAKoA1wDfAKwA4gDkALUA5wDnALgA6QDpALkA7ADsALoA7wD5ALsA/wEIAMYBFgEWANABKgEtANEBOQE8ANUBRgFGANkAAQABAUYABwAHAAcABwAHAAcABwAIABYAFwAXAAQAAAAIAAgACAAIAAgAJAAlAAEAAQAYAAEAAQAYAAoAJgAnAAEAAQABAAQABAAEAAQABAAEAAQACAAoAAQAKQAZACoACgAKAAoACgAKACsALAAtABoAGgAuAAUABQAFAAUABQAFAAUACQACABMAEwABAAkACQAJAAkACQAvADIABQALAAsANgALAAsACwAAAAsANwABAAEABQAFAAUAAgACAAIAAgACAAIAAgAJAAIAAgA5ADsAFgA9AA0ADQANAA0ADQANAA8AQQBCAA8ADwAPAEMAAAACAAIAGQATAAAAAAAAAB8AOAA+ABwAMAAAAAAAPAAcAB8AAAAAAAAAAAAAABEAEgARABIAEQASAAAAFQAAABUAAAAVAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiACMAAAAgACAAIgAjACEAIQAAAAAAFAAUABQAGwAAABsAAAAdAB4AHQAeAAAAAAAMAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAADAAAAAAAAAAQABAAAAA6AAQADgAQAA4ADgAOAA4AAQAAAAAAPwADAEAAAAAAADMAAAA0AAAAAAA1AAAAAAAxAAYABgAGAAYABgAGAAYABgAGAAYAAAAAAAAAAAAAAAMAAwADAAMAAwADAAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAEAAEAAQFGAAcABwAHAAcABwAHAAcABwABAAQABAABAAAAAQABAAEAAQABAAEABAABAAEAFgABAAEAFgAhAAEAAQABAAEAAQAEAAQABAAEAAQABAAEAAQAAQAEAAEAFwAiAAAAAAAAAAAAAAAjACQAJQAYABgAJgAIAAgACAAIAAgACAAIAAgAAQADAAMAAwADAAMAAwADAAMAJwADAAEADQANACwADQANAA0AAAAtAAEAAQABAAoACgAKAAMAAwADAAMAAwADAAMAAwAKAAoACgAxAAEAMwALAAsACwALAAsACwAPADkAOgAPAA8ADwA7AAEAAwABABcAAwAAAAAAAAAfAC4ANQA0ACgAAAAfAAAAAAAAAAAAAAAAAAAAAAARABIAEQASABEAEgAAAAAAFQAAABUAAAAVAAAAAAAAADIAAQAAAAAAAgACAAAAAAAMAAIAAAAAAAwAHQAeAAAAGwAbAB0AHgAcABwAAAAAABQAFAAUABMAEwATAAIAGQAaABkAGgAAAAAACQACAAIADAACAAkAAgAAAAAACQACAAIADAACAAkAAgACAAAAEAAQAAwAMAAEAA4AEAAOAA4ADgAOAC8AAAA3AAAANgA4AAAAKQAAACoAKwAAAAAAAAAAAAAAAAAGAAYABgAGAAYABgAGAAYABgAGAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgACAAIACQAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgACAAIACQAJAAAAAAAAAAAAIAABAAAACgBEAKAAAkRGTFQADmxhdG4AEgAOAAAACgABQ0FUIAAYAAD//wAEAAAAAQACAAQAAP//AAUAAAABAAIAAwAEAAVjYWx0ACBkbm9tACxmcmFjADJsb2NsAFBudW1yAFYAAAAEAB8AIAAjACQAAAABAB4AAAANAAMABQAHAAkACwANAA8AEQATABUAFwAZABsAAAABAAAAAAABAB0AQACCALoA2gD6AzIDRgSqA2AEqgN8BKoDmgSqA7oEqgPcBKoEAASqBCYEqgROBKoEeASqBLgE3ATqBRYFKgV8Bb4XABdaF3oXohk8IQYhOCE4ITghOCE4ITghOCE4IbohuiG6IbohuiG6IbohuiG6IboiNCJmImYiZiJmImYiZiJmAAYAAAACAAoAHgADAAAAAgA+ACgAAQA+AAEAAAABAAMAAAACAEoAFAABAEoAAQAAAAIAAQABALsABAAAAAEACAABAAgAAQAOAAEAAQBWAAEABABXAAIAuwAEAAAAAQAIAAEACAABAA4AAQABAB0AAQAEAUcAAgC7AAYAAAAVADAAUgB0AJQAtADSAPABDAEoAUIBXAF0AYwBogG4AcwB4AHyAgQCFAIkAAMACx/SH9If0h/SH9If0h/SH9If0h/SAhYAAQIWAAAAAAADAAAAAQH0AAsfsB+wH7AfsB+wH7AfsB+wH7AfsAH0AAAAAwAKH44fjh+OH44fjh+OH44fjh+OAdIAAQHSAAAAAAADAAAAAQGyAAofbh9uH24fbh9uH24fbh9uH24BsgAAAAMACR9OH04fTh9OH04fTh9OH04BkgABAZIAAAAAAAMAAAABAXQACR8wHzAfMB8wHzAfMB8wHzABdAAAAAMACB8SHxIfEh8SHxIfEh8SAVYAAQFWAAAAAAADAAAAAQE6AAge9h72HvYe9h72HvYe9gE6AAAAAwAHHtoe2h7aHtoe2h7aAR4AAQEeAAAAAAADAAAAAQEEAAcewB7AHsAewB7AHsABBAAAAAMABh6mHqYeph6mHqYA6gABAOoAAAAAAAMAAAABANIABh6OHo4ejh6OHo4A0gAAAAMABR52HnYedh52ALoAAQC6AAAAAAADAAAAAQCkAAUeYB5gHmAeYACkAAAAAwAEHkoeSh5KAI4AAQCOAAAAAAADAAAAAQB6AAQeNh42HjYAegAAAAMAAx4iHiIAZgABAGYAAAAAAAMAAAABAFQAAx4QHhAAVAAAAAMAAh3+AEIAAQBCAAAAAAADAAAAAQAyAAId7gAyAAAAAwABHd4AAQAiAAEd3gABAAAABAABAAAAAQAIAAEABgBSAAEAAQCdAAYAAAABAAgAAwAAAAEdrgABAVYAAQAAAAYABgAAAAEACAADAAAAAR2UAAIBngE8AAEAAAAIAAYAAAABAAgAAwAAAAEdeAADAYIBggEgAAEAAAAKAAYAAAABAAgAAwAAAAEdWgAEAWQBZAFkAQIAAQAAAAwABgAAAAEACAADAAAAAR06AAUBRAFEAUQBRADiAAEAAAAOAAYAAAABAAgAAwAAAAEdGAAGASIBIgEiASIBIgDAAAEAAAAQAAYAAAABAAgAAwAAAAEc9AAHAP4A/gD+AP4A/gD+AJwAAQAAABIABgAAAAEACAADAAAAARzOAAgA2ADYANgA2ADYANgA2AB2AAEAAAAUAAYAAAABAAgAAwAAAAEcpgAJALAAsACwALAAsACwALAAsABOAAEAAAAWAAYAAAABAAgAAwAAAAEcfAAKAIYAhgCGAIYAhgCGAIYAhgCGACQAAQAAABgAAQABAO8AAQAAAAEACAABHEoAkAAGAAAAAQAIAAMAAQASAAEcPAAAAAEAAAAaAAIAAQDlAPkAAAABAAAAAQAIAAEcGABnAAYAAAABAAgAAwABHAoAAQAyAAEAFAABAAAAHAACAAIA/wEIAAABDgEXAAoAAQAAAAEACAABAAYAAwABAAEBJQABAAAAAQAIAAIAKAARAN0A3gD/AQABAQECAQMBBAEFAQYBBwEIAQwBDQELAQkBCgACAAUATQBNAAAAWQBZAAEAfgCHAAIAjQCOAAwAwgDEAA4AAQAAAAEACAACACQADwDwAPEA8gDzAPQA9QD2APcA+AD5AP0A/gD8APoA+wACAAMAfgCHAAAAjQCOAAoAwgDEAAwABAAAAAEACAABESYACAAWAI4AjgF4AdYB1gPMBXwAOADqAhgCIgD0AiwCNgD+AkACSgJUAl4CaAJyAnwChgEIApACmgESAqQCrgEcArgCwgLMAtYC4ALqAvQC/gEmAwgDEgEwAxwDJgE6AzADOgNEA04DWANiA2wDdgFEA4ADiAFMA5ADmAFUA6ADqAByAboBLgACAMEAOAByAaABqgB8AbQBvgCGAcgB0gHcAeYB8AH6AgQCDgCQAhgCIgCaAiwCNgCkAkACSgJUAl4CaAJyAnwChgCuApACmgC4AqQCrgDCArgCwgLMAtYC4ALqAvQC/gDMAwgDEADUAxgDIADcAygDMADkAzgBMAAEAKQApADBATAABACkAKMAwQEwAAQApAChAMEBMAAEAKMApADBATAABACjAKMAwQEwAAQAowChAMEBMAAEAKEApADBATAABAChAKMAwQEwAAQAoQChAMEBLwADAKQAwQEvAAMAowDBAS8AAwChAMEBLwACAMEAKwC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbABugHEAc4B2AHiAewB9gIAAgoCFAIeAiYCLgI2Aj4CRgBYAT0AAgDKACsAWABiAGwAdgCAAIoAlACeAKgAsgC8AMYA0ADaAOQA7gD4AQIBDAEWASABKgE0AT4BSAFSAVwBZgFwAXoBhAGOAZgBogGsAbYBwAHIAdAB2AHgAegB8AE/AAQApACkAMoBPwAEAKQAqADKAT8ABACkAKMAygE/AAQApACnAMoBPwAEAKQAoQDKAT8ABACkAKYAygE/AAQAqACkAMoBPwAEAKgAqADKAT8ABACoAKMAygE/AAQAqACnAMoBPwAEAKgAoQDKAT8ABACoAKYAygE/AAQAowCkAMoBPwAEAKMAqADKAT8ABACjAKMAygE/AAQAowCnAMoBPwAEAKMAoQDKAT8ABACjAKYAygE/AAQApwCkAMoBPwAEAKcAqADKAT8ABACnAKMAygE/AAQApwCnAMoBPwAEAKcAoQDKAT8ABACnAKYAygE/AAQAoQCkAMoBPwAEAKEAqADKAT8ABAChAKMAygE/AAQAoQCnAMoBPwAEAKEAoQDKAT8ABAChAKYAygE/AAQApgCkAMoBPwAEAKYAqADKAT8ABACmAKMAygE/AAQApgCnAMoBPwAEAKYAoQDKAT8ABACmAKYAygE+AAMApADKAT4AAwCoAMoBPgADAKMAygE+AAMApwDKAT4AAwChAMoBPgADAKYAygE+AAIAygAmAE4AWABiAGwAdgCAAIoAlACeAKgAsgC8AMYA0ADaAOQA7gD4AQIBDAEWASABKgE0AT4BSAFSAVwBZAFsAXQBfAGEAYwBlAGcAaQBqgEsAAQApACkAKQBLAAEAKQApACjASwABACkAKQAoQEsAAQApACjAKQBLAAEAKQAowCjASwABACkAKMAoQEsAAQApAChAKQBLAAEAKQAoQCjASwABACkAKEAoQEsAAQAowCkAKQBLAAEAKMApACjASwABACjAKQAoQEsAAQAowCjAKQBLAAEAKMAowCjASwABACjAKMAoQEsAAQAowChAKQBLAAEAKMAoQCjASwABACjAKEAoQEsAAQAoQCkAKQBLAAEAKEApACjASwABAChAKQAoQEsAAQAoQCjAKQBLAAEAKEAowCjASwABAChAKMAoQEsAAQAoQChAKQBLAAEAKEAoQCjASwABAChAKEAoQErAAMApACkASsAAwCkAKMBKwADAKQAoQErAAMAowCkASsAAwCjAKMBKwADAKMAoQErAAMAoQCkASsAAwChAKMBKwADAKEAoQErAAIApAErAAIAowEAAgICDAIWAiACKgI0Aj4CSAJSAlwCZgJwAnoChAKOApgCogKsArYCwALKAtQC3gLoAvIC/AMGAxADGgMkAy4DOANCA0wDVgNgA2oDdAN+A4gDkgOcA6YDsAO6A8QDzgPYA+ID7AP2BAAECgQUBB4EKAQyBDwERgRQBFoEZARuBHgEggSMBJYEoASqBLQEvgTIBNIE3ATmBPAE+gUEBQ4FGAUiBSwFNgVABUoFVAVeBWgFcgV8BYYFkAWaBaQFrgW4BcIFzAXWBeAF6gX0Bf4GCAYSBhwGJgYwBjoGRAZOBlgGYgZsBnYGgAaKBpQGngaoBrIGvAbGBtAG2gbkBu4G+AcCBwwHFgcgByoHNAc+B0gHUgdcB2YHcAd6B4QHjgeYB6IHrAe2B8AHygfUB94H6AfyB/wIBggQCBoIJAguCDgIQghMCFYIYAhqCHQIfgiICJIInAimCLAIugjECM4I2AjiCOwI9gkACQoJFAkeCSgJMgk8CUYJUAlaCWQJbgl4CYIJjAmWCaAJqgm0Cb4JyAnSCdwJ5gnwCfoKBAoOChgKIgosCjYKQApKClQKXgpoCnIKegqCCooKkgqaCqIKqgqyCroKwgrKCtIK2griCuoK8gr6CwILCgsSCxoLIgsqCzILOgtCC0oLUgtaC2ILagtyC3oLgguKC5ILmAueC6QBOwAEAKQApACkATsABACkAKQAqAE7AAQApACkAKMBOwAEAKQApACnATsABACkAKQAoQE7AAQApACkAKYBOwAEAKQAqACkATsABACkAKgAqAE7AAQApACoAKMBOwAEAKQAqACnATsABACkAKgAoQE7AAQApACoAKYBOwAEAKQAowCkATsABACkAKMAqAE7AAQApACjAKMBOwAEAKQAowCnATsABACkAKMAoQE7AAQApACjAKYBOwAEAKQApwCkATsABACkAKcAqAE7AAQApACnAKMBOwAEAKQApwCnATsABACkAKcAoQE7AAQApACnAKYBOwAEAKQAoQCkATsABACkAKEAqAE7AAQApAChAKMBOwAEAKQAoQCnATsABACkAKEAoQE7AAQApAChAKYBOwAEAKQApgCkATsABACkAKYAqAE7AAQApACmAKMBOwAEAKQApgCnATsABACkAKYAoQE7AAQApACmAKYBOwAEAKgApACkATsABACoAKQAqAE7AAQAqACkAKMBOwAEAKgApACnATsABACoAKQAoQE7AAQAqACkAKYBOwAEAKgAqACkATsABACoAKgAqAE7AAQAqACoAKMBOwAEAKgAqACnATsABACoAKgAoQE7AAQAqACoAKYBOwAEAKgAowCkATsABACoAKMAqAE7AAQAqACjAKMBOwAEAKgAowCnATsABACoAKMAoQE7AAQAqACjAKYBOwAEAKgApwCkATsABACoAKcAqAE7AAQAqACnAKMBOwAEAKgApwCnATsABACoAKcAoQE7AAQAqACnAKYBOwAEAKgAoQCkATsABACoAKEAqAE7AAQAqAChAKMBOwAEAKgAoQCnATsABACoAKEAoQE7AAQAqAChAKYBOwAEAKgApgCkATsABACoAKYAqAE7AAQAqACmAKMBOwAEAKgApgCnATsABACoAKYAoQE7AAQAqACmAKYBOwAEAKMApACkATsABACjAKQAqAE7AAQAowCkAKMBOwAEAKMApACnATsABACjAKQAoQE7AAQAowCkAKYBOwAEAKMAqACkATsABACjAKgAqAE7AAQAowCoAKMBOwAEAKMAqACnATsABACjAKgAoQE7AAQAowCoAKYBOwAEAKMAowCkATsABACjAKMAqAE7AAQAowCjAKMBOwAEAKMAowCnATsABACjAKMAoQE7AAQAowCjAKYBOwAEAKMApwCkATsABACjAKcAqAE7AAQAowCnAKMBOwAEAKMApwCnATsABACjAKcAoQE7AAQAowCnAKYBOwAEAKMAoQCkATsABACjAKEAqAE7AAQAowChAKMBOwAEAKMAoQCnATsABACjAKEAoQE7AAQAowChAKYBOwAEAKMApgCkATsABACjAKYAqAE7AAQAowCmAKMBOwAEAKMApgCnATsABACjAKYAoQE7AAQAowCmAKYBOwAEAKcApACkATsABACnAKQAqAE7AAQApwCkAKMBOwAEAKcApACnATsABACnAKQAoQE7AAQApwCkAKYBOwAEAKcAqACkATsABACnAKgAqAE7AAQApwCoAKMBOwAEAKcAqACnATsABACnAKgAoQE7AAQApwCoAKYBOwAEAKcAowCkATsABACnAKMAqAE7AAQApwCjAKMBOwAEAKcAowCnATsABACnAKMAoQE7AAQApwCjAKYBOwAEAKcApwCkATsABACnAKcAqAE7AAQApwCnAKMBOwAEAKcApwCnATsABACnAKcAoQE7AAQApwCnAKYBOwAEAKcAoQCkATsABACnAKEAqAE7AAQApwChAKMBOwAEAKcAoQCnATsABACnAKEAoQE7AAQApwChAKYBOwAEAKcApgCkATsABACnAKYAqAE7AAQApwCmAKMBOwAEAKcApgCnATsABACnAKYAoQE7AAQApwCmAKYBOwAEAKEApACkATsABAChAKQAqAE7AAQAoQCkAKMBOwAEAKEApACnATsABAChAKQAoQE7AAQAoQCkAKYBOwAEAKEAqACkATsABAChAKgAqAE7AAQAoQCoAKMBOwAEAKEAqACnATsABAChAKgAoQE7AAQAoQCoAKYBOwAEAKEAowCkATsABAChAKMAqAE7AAQAoQCjAKMBOwAEAKEAowCnATsABAChAKMAoQE7AAQAoQCjAKYBOwAEAKEApwCkATsABAChAKcAqAE7AAQAoQCnAKMBOwAEAKEApwCnATsABAChAKcAoQE7AAQAoQCnAKYBOwAEAKEAoQCkATsABAChAKEAqAE7AAQAoQChAKMBOwAEAKEAoQCnATsABAChAKEAoQE7AAQAoQChAKYBOwAEAKEApgCkATsABAChAKYAqAE7AAQAoQCmAKMBOwAEAKEApgCnATsABAChAKYAoQE7AAQAoQCmAKYBOwAEAKYApACkATsABACmAKQAqAE7AAQApgCkAKMBOwAEAKYApACnATsABACmAKQAoQE7AAQApgCkAKYBOwAEAKYAqACkATsABACmAKgAqAE7AAQApgCoAKMBOwAEAKYAqACnATsABACmAKgAoQE7AAQApgCoAKYBOwAEAKYAowCkATsABACmAKMAqAE7AAQApgCjAKMBOwAEAKYAowCnATsABACmAKMAoQE7AAQApgCjAKYBOwAEAKYApwCkATsABACmAKcAqAE7AAQApgCnAKMBOwAEAKYApwCnATsABACmAKcAoQE7AAQApgCnAKYBOwAEAKYAoQCkATsABACmAKEAqAE7AAQApgChAKMBOwAEAKYAoQCnATsABACmAKEAoQE7AAQApgChAKYBOwAEAKYApgCkATsABACmAKYAqAE7AAQApgCmAKMBOwAEAKYApgCnATsABACmAKYAoQE7AAQApgCmAKYBOgADAKQApAE6AAMApACoAToAAwCkAKMBOgADAKQApwE6AAMApAChAToAAwCkAKYBOgADAKgApAE6AAMAqACoAToAAwCoAKMBOgADAKgApwE6AAMAqAChAToAAwCoAKYBOgADAKMApAE6AAMAowCoAToAAwCjAKMBOgADAKMApwE6AAMAowChAToAAwCjAKYBOgADAKcApAE6AAMApwCoAToAAwCnAKMBOgADAKcApwE6AAMApwChAToAAwCnAKYBOgADAKEApAE6AAMAoQCoAToAAwChAKMBOgADAKEApwE6AAMAoQChAToAAwChAKYBOgADAKYApAE6AAMApgCoAToAAwCmAKMBOgADAKYApwE6AAMApgChAToAAwCmAKYBOgACAKQBOgACAKgBOgACAKMBOgACAKcAAQAIAKEAowCkAKYApwCoAMAAyQAGAAAABAAOAB4ALgBAAAMAAAACAFwC7AABCe4AAAADAAAAAgBsADQAAQneAAAAAwAAAAIAPALMAAAAAQAAACEAAwAAAAIASgASAAAAAQAAACIAAQACAKEApgAEAAAAAQAIAAEACAABAA4AAQABAMAAAQAEASoAAgChAAQAAAABAAgAAQAIAAEADgABAAEAyQACAAYADAE5AAIAoQE5AAIApgAEAAAAAQAIAAEBfgAIABYATABmASgBRgFQAVoBbAAHABAAGgAiACoBBgAwAQwBNgAEAMIAwgDBAS0AAwDCAMIBNQADAMIAwQEzAAIBLgE0AAIBLwAFAAwA5ADsABQA9AEyAAMAwgDBATEAAgDBABIAJgAwADoARABOAFgAYgBsAHYAfgCGAI4AlgCeAKYArgC2ALwBRQAEAMIAwgDBAUUABADCAMIAygFFAAQAwgDLAMEBRQAEAMIAywDKAUUABADLAMIAwQFFAAQAywDCAMoBRQAEAMsAywDBAUUABADLAMsAygE8AAMAwgDCATwAAwDCAMsBRAADAMIAwQFEAAMAwgDKATwAAwDLAMIBPAADAMsAywFEAAMAywDBAUQAAwDLAMoBQgACAT0BQwACAT4AAwAIABAAGAFBAAMAwgDKAUEAAwDLAMoBQAACAMoAAQAEATMAAgDBAAEABAE0AAIAwQACAAYADAFC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) format('truetype');
}
p, ul, a {
font-family: var(--main-font);
}
h1, h2, h3, h4 {
font-family: var(--header-font);
}


h1, h2, h3, h4 {
color: var(--main-color)
}
h1.title, h1.subtitle, h2.author, h2.date {
color: #ffffff;
}

h1.title {
font-size: 50pt;
margin-right: 15%;
font-weight: 700;
}
h1.subtitle {
margin-right: 15%;
font-size: 25pt;
}
h2.author {
margin-top: 70%;
font-size: 25pt;
}
h2.date {
font-size: 25pt;
}

h1 {
font-size: 40pt;
}
h2 {
font-size: 24pt;
}

p, ul {
margin-right: 15%;
}


.level1 {
page: chapter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

caption {
break-inside: avoid;
break-after: avoid;
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Title of the report</h1>
<h1 class="subtitle"><span>Subtitle of the report</span></h1>
<h2 class="author">Author Name</h2>
<h2 class="date">Date</h2>
</div>

<div class="main-color" style="display: none;">#6cabdd</div>
<script>
(function() {
    let mainColor = document.querySelector('.main-color');
    let mainColorCont = mainColor.textContent;
    document.documentElement.style.setProperty('--main-color', mainColorCont);
})();
</script>




</div>

<div class="front-matter-container">
</div>

<div class="main">
<div id="this-is-part-1" class="section level1 unnumbered">
<h1>This is part 1</h1>
<div id="second-level" class="section level2 unnumbered">
<h2>Second level</h2>
<p>This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.</p>
<p>This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.
Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.</p>
<p>This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
</div>
<div id="second-level-1" class="section level2 unnumbered">
<h2>Second level</h2>
<p>Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
<p>Finally, be sure to remove this message! This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.
Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.</p>
<p>This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
<p>Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.
Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.</p>
<p>This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
<p>Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
<p>Finally, be sure to remove this message!This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.
Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.
Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
</div>
<div id="second-level-2" class="section level2 unnumbered">
<h2>Second level</h2>
<p>Finally, be sure to remove this message!
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.
Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.</p>
<p>This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
<p>Finally, be sure to remove this message!
This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.
This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
</div>
</div>
<div id="and-now-part-2" class="section level1 unnumbered">
<h1>And now part 2</h1>
<p>This file is what a user will see when they select your template. Make sure that you update the fields in the yaml header. In particular you will want to update the <code>output</code> field to whatever format your template requires.</p>
<div id="second-level-3" class="section level2 unnumbered">
<h2>Second level</h2>
<p>This is a good place to demonstrate special features that your template provides. Ideally it should knit out-of-the-box, or at least contain clear instructions as to what needs changing.</p>
<p>Finally, be sure to remove this message!</p>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
